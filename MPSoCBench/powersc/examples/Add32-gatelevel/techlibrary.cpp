///////////////////////////////////////////////////
// Date of creation: Thu Oct 12 14:27:59 2006
//
// This file was automatically generated by the
// psclib2sc tool.
//
// psclib2sc is part of the PowerSC suite
//
// LSC - Computer Systems Laboratory
// http://www.lsc.ic.unicamp.br
///////////////////////////////////////////////////

#include "techlibrary.h"

// values for the library units
const double LibUnits::voltage = 1;
const double LibUnits::capacitive = 1e-15;
const double LibUnits::time = 1e-12;
const double LibUnits::leakage_power = 0.001;
const double LibUnits::dynamic_power = 0.001;

void LibUnits::use_lib_time()
{
	sc_set_default_time_unit( 1, SC_PS );
}
// values for the library operating conditions
const double LibOperCond::voltage = 2.5;
const double LibOperCond::process = 1;
const double LibOperCond::temperature = 25;
const rc_tree_type_t LibOperCond::tree_type = BEST_CASE_TREE;
// values for the 'default' wire load model
// default -> VTVT .25um library wireload model: 05x05
const double LibWireLoad::resistance = 0.0;
const double LibWireLoad::capacitance = 0.0001;
const double LibWireLoad::fanout_length[10] = {0.39, 0.39, 0.39, 0.39, 0.39, 0.39, 0.39, 0.39, 0.39};

// MODULE: and2_1
// PROCESS NAME: proc
void and2_1::proc()
{
	op.write(
		( ip1.read() & ip2.read() ) 
	);
}

and2_1::~and2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and2_1::celltype = "and2_1";
const double and2_1::leakage_power = 3.50672e-08;
const double and2_1::capacitance_ip1 = 5.2265;
const double and2_1::fanout_load_ip1 = 1;
const double and2_1::capacitance_ip2 = 5.4466;
const double and2_1::fanout_load_ip2 = 1;
const double and2_1::max_capacitance_op = 250;
const double and2_1::max_fanout_op = 50;

const double and2_1::power_op_ip1_fall[4][4] = {
	{76.511, 75.336, 83.13, 161.91},
	{78.442, 76.668, 82.981, 155.04},
	{79.407, 77.665, 83.689, 153.09},
	{79.649, 78.118, 84.324, 151.2}
};
const double and2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and2_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_1::power_op_ip1_rise[4][4] = {
	{73.923, 72.364, 82.448, 182.46},
	{75.226, 72.601, 81.061, 174.83},
	{75.677, 72.833, 80.719, 171.52},
	{75.93, 73.133, 80.806, 168.12}
};
const double and2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and2_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and2_1::power_op_ip2_fall[4][4] = {
	{76.511, 75.336, 83.13, 161.91},
	{78.442, 76.668, 82.981, 155.04},
	{79.407, 77.665, 83.689, 153.09},
	{79.649, 78.118, 84.324, 151.2}
};
const double and2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and2_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_1::power_op_ip2_rise[4][4] = {
	{73.923, 72.364, 82.448, 182.46},
	{75.226, 72.601, 81.061, 174.83},
	{75.677, 72.833, 80.719, 171.52},
	{75.93, 73.133, 80.806, 168.12}
};
const double and2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and2_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and2_2
// PROCESS NAME: proc
void and2_2::proc()
{
	op.write(
		( ip1.read() & ip2.read() ) 
	);
}

and2_2::~and2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and2_2::celltype = "and2_2";
const double and2_2::leakage_power = 4.38588e-08;
const double and2_2::capacitance_ip1 = 10.036;
const double and2_2::fanout_load_ip1 = 2;
const double and2_2::capacitance_ip2 = 10.095;
const double and2_2::fanout_load_ip2 = 2;
const double and2_2::max_capacitance_op = 250;
const double and2_2::max_fanout_op = 50;

const double and2_2::power_op_ip1_fall[4][4] = {
	{136.02, 133.76, 149.23, 301.37},
	{138.72, 135.35, 148.34, 290.79},
	{140.96, 137.45, 149.71, 287.64},
	{142.6, 139.29, 151.48, 283.18}
};
const double and2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and2_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_2::power_op_ip1_rise[4][4] = {
	{130.91, 127.99, 147.74, 342.07},
	{133.15, 128.37, 146.39, 332.17},
	{134.55, 129.06, 145.68, 326.24},
	{135.42, 129.94, 145.35, 317.26}
};
const double and2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and2_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and2_2::power_op_ip2_fall[4][4] = {
	{136.02, 133.76, 149.23, 301.37},
	{138.72, 135.35, 148.34, 290.79},
	{140.96, 137.45, 149.71, 287.64},
	{142.6, 139.29, 151.48, 283.18}
};
const double and2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and2_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_2::power_op_ip2_rise[4][4] = {
	{130.91, 127.99, 147.74, 342.07},
	{133.15, 128.37, 146.39, 332.17},
	{134.55, 129.06, 145.68, 326.24},
	{135.42, 129.94, 145.35, 317.26}
};
const double and2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and2_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and2_4
// PROCESS NAME: proc
void and2_4::proc()
{
	op.write(
		( ip1.read() & ip2.read() ) 
	);
}

and2_4::~and2_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and2_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and2_4::celltype = "and2_4";
const double and2_4::leakage_power = 6.4555e-08;
const double and2_4::capacitance_ip1 = 10.006;
const double and2_4::fanout_load_ip1 = 2;
const double and2_4::capacitance_ip2 = 9.9234;
const double and2_4::fanout_load_ip2 = 2;
const double and2_4::max_capacitance_op = 250;
const double and2_4::max_fanout_op = 50;

const double and2_4::power_op_ip1_fall[4][4] = {
	{196.91, 197.97, 217.89, 401.56},
	{192.54, 191.15, 207.57, 376.78},
	{194.01, 190.87, 204.93, 361.69},
	{198.92, 196.11, 207.29, 341.95}
};
const double and2_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and2_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_4::power_op_ip1_rise[4][4] = {
	{193.18, 193.76, 219.87, 447.05},
	{187.55, 186.96, 209.64, 424.04},
	{187.37, 185, 204.77, 408.47},
	{188.33, 183.49, 198.84, 378.72}
};
const double and2_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and2_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and2_4::power_op_ip2_fall[4][4] = {
	{196.91, 197.97, 217.89, 401.56},
	{192.54, 191.15, 207.57, 376.78},
	{194.01, 190.87, 204.93, 361.69},
	{198.92, 196.11, 207.29, 341.95}
};
const double and2_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and2_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and2_4::power_op_ip2_rise[4][4] = {
	{193.18, 193.76, 219.87, 447.05},
	{187.55, 186.96, 209.64, 424.04},
	{187.37, 185, 204.77, 408.47},
	{188.33, 183.49, 198.84, 378.72}
};
const double and2_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and2_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and3_1
// PROCESS NAME: proc
void and3_1::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

and3_1::~and3_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and3_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and3_1::celltype = "and3_1";
const double and3_1::leakage_power = 2.84642e-08;
const double and3_1::capacitance_ip1 = 6.1818;
const double and3_1::fanout_load_ip1 = 1;
const double and3_1::capacitance_ip2 = 6.2161;
const double and3_1::fanout_load_ip2 = 1;
const double and3_1::capacitance_ip3 = 5.0749;
const double and3_1::fanout_load_ip3 = 1;
const double and3_1::max_capacitance_op = 250;
const double and3_1::max_fanout_op = 50;

const double and3_1::power_op_ip1_fall[4][4] = {
	{91.494, 90.013, 95.744, 166.75},
	{92.099, 90.16, 94.349, 158.32},
	{92.801, 90.949, 94.933, 155.6},
	{92.832, 90.969, 94.735, 152.1}
};
const double and3_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_1::power_op_ip1_rise[4][4] = {
	{91.603, 88.271, 95.173, 184.81},
	{89.066, 85.432, 91.337, 175.54},
	{88.514, 84.606, 89.956, 171.13},
	{87.93, 83.867, 88.756, 165.67}
};
const double and3_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_1::power_op_ip2_fall[4][4] = {
	{91.494, 90.013, 95.744, 166.75},
	{92.099, 90.16, 94.349, 158.32},
	{92.801, 90.949, 94.933, 155.6},
	{92.832, 90.969, 94.735, 152.1}
};
const double and3_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_1::power_op_ip2_rise[4][4] = {
	{91.603, 88.271, 95.173, 184.81},
	{89.066, 85.432, 91.337, 175.54},
	{88.514, 84.606, 89.956, 171.13},
	{87.93, 83.867, 88.756, 165.67}
};
const double and3_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_1::power_op_ip3_fall[4][4] = {
	{91.494, 90.013, 95.744, 166.75},
	{92.099, 90.16, 94.349, 158.32},
	{92.801, 90.949, 94.933, 155.6},
	{92.832, 90.969, 94.735, 152.1}
};
const double and3_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_1::power_op_ip3_rise[4][4] = {
	{91.603, 88.271, 95.173, 184.81},
	{89.066, 85.432, 91.337, 175.54},
	{88.514, 84.606, 89.956, 171.13},
	{87.93, 83.867, 88.756, 165.67}
};
const double and3_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and3_1::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and3_2
// PROCESS NAME: proc
void and3_2::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

and3_2::~and3_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and3_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and3_2::celltype = "and3_2";
const double and3_2::leakage_power = 3.69412e-08;
const double and3_2::capacitance_ip1 = 10.415;
const double and3_2::fanout_load_ip1 = 2;
const double and3_2::capacitance_ip2 = 10.06;
const double and3_2::fanout_load_ip2 = 2;
const double and3_2::capacitance_ip3 = 9.951;
const double and3_2::fanout_load_ip3 = 2;
const double and3_2::max_capacitance_op = 250;
const double and3_2::max_fanout_op = 50;

const double and3_2::power_op_ip1_fall[4][4] = {
	{166.17, 164.17, 176.23, 315.57},
	{167.49, 164.13, 173.84, 303.07},
	{169.43, 166.24, 175.13, 297.58},
	{171.31, 168.35, 176.32, 291.1}
};
const double and3_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_2::power_op_ip1_rise[4][4] = {
	{164.49, 159.31, 174.27, 350.64},
	{161.74, 155.93, 169.28, 337.92},
	{161.43, 155.07, 167.31, 330.27},
	{161.5, 154.72, 165.38, 318.5}
};
const double and3_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_2::power_op_ip2_fall[4][4] = {
	{166.17, 164.17, 176.23, 315.57},
	{167.49, 164.13, 173.84, 303.07},
	{169.43, 166.24, 175.13, 297.58},
	{171.31, 168.35, 176.32, 291.1}
};
const double and3_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_2::power_op_ip2_rise[4][4] = {
	{164.49, 159.31, 174.27, 350.64},
	{161.74, 155.93, 169.28, 337.92},
	{161.43, 155.07, 167.31, 330.27},
	{161.5, 154.72, 165.38, 318.5}
};
const double and3_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_2::power_op_ip3_fall[4][4] = {
	{166.17, 164.17, 176.23, 315.57},
	{167.49, 164.13, 173.84, 303.07},
	{169.43, 166.24, 175.13, 297.58},
	{171.31, 168.35, 176.32, 291.1}
};
const double and3_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_2::power_op_ip3_rise[4][4] = {
	{164.49, 159.31, 174.27, 350.64},
	{161.74, 155.93, 169.28, 337.92},
	{161.43, 155.07, 167.31, 330.27},
	{161.5, 154.72, 165.38, 318.5}
};
const double and3_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and3_2::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and3_4
// PROCESS NAME: proc
void and3_4::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

and3_4::~and3_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and3_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and3_4::celltype = "and3_4";
const double and3_4::leakage_power = 5.80186e-08;
const double and3_4::capacitance_ip1 = 11.488;
const double and3_4::fanout_load_ip1 = 2;
const double and3_4::capacitance_ip2 = 10.664;
const double and3_4::fanout_load_ip2 = 2;
const double and3_4::capacitance_ip3 = 10.169;
const double and3_4::fanout_load_ip3 = 2;
const double and3_4::max_capacitance_op = 250;
const double and3_4::max_fanout_op = 50;

const double and3_4::power_op_ip1_fall[4][4] = {
	{234.83, 235.55, 253.19, 432.59},
	{227.92, 227.53, 241.34, 407.17},
	{228.01, 225.27, 237.2, 388.48},
	{232.12, 229.64, 237.64, 363.02}
};
const double and3_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_4::power_op_ip1_rise[4][4] = {
	{257.69, 253.99, 273.72, 487.56},
	{242.59, 238.85, 256.57, 462.18},
	{233.77, 229.67, 245.98, 440.76},
	{224.32, 218.22, 230.29, 401.47}
};
const double and3_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_4::power_op_ip2_fall[4][4] = {
	{234.83, 235.55, 253.19, 432.59},
	{227.92, 227.53, 241.34, 407.17},
	{228.01, 225.27, 237.2, 388.48},
	{232.12, 229.64, 237.64, 363.02}
};
const double and3_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_4::power_op_ip2_rise[4][4] = {
	{257.69, 253.99, 273.72, 487.56},
	{242.59, 238.85, 256.57, 462.18},
	{233.77, 229.67, 245.98, 440.76},
	{224.32, 218.22, 230.29, 401.47}
};
const double and3_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and3_4::power_op_ip3_fall[4][4] = {
	{234.83, 235.55, 253.19, 432.59},
	{227.92, 227.53, 241.34, 407.17},
	{228.01, 225.27, 237.2, 388.48},
	{232.12, 229.64, 237.64, 363.02}
};
const double and3_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and3_4::power_op_ip3_rise[4][4] = {
	{257.69, 253.99, 273.72, 487.56},
	{242.59, 238.85, 256.57, 462.18},
	{233.77, 229.67, 245.98, 440.76},
	{224.32, 218.22, 230.29, 401.47}
};
const double and3_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and3_4::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and4_1
// PROCESS NAME: proc
void and4_1::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

and4_1::~and4_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and4_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and4_1::celltype = "and4_1";
const double and4_1::leakage_power = 2.36382e-08;
const double and4_1::capacitance_ip1 = 6.216;
const double and4_1::fanout_load_ip1 = 1;
const double and4_1::capacitance_ip2 = 5.6857;
const double and4_1::fanout_load_ip2 = 1;
const double and4_1::capacitance_ip3 = 5.6497;
const double and4_1::fanout_load_ip3 = 1;
const double and4_1::capacitance_ip4 = 5.3444;
const double and4_1::fanout_load_ip4 = 1;
const double and4_1::max_capacitance_op = 250;
const double and4_1::max_fanout_op = 50;

const double and4_1::power_op_ip1_fall[4][4] = {
	{97.106, 96.114, 101.3, 169.47},
	{97.869, 96.138, 99.843, 160.44},
	{98.635, 97.199, 100.32, 157.12},
	{98.804, 97.31, 100.16, 153.11}
};
const double and4_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_1::power_op_ip1_rise[4][4] = {
	{101.13, 97.461, 103.38, 189.88},
	{95.735, 91.908, 97.073, 178.59},
	{94.256, 90.05, 94.797, 173.22},
	{92.592, 88.229, 92.482, 166.26}
};
const double and4_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_1::power_op_ip2_fall[4][4] = {
	{97.106, 96.114, 101.3, 169.47},
	{97.869, 96.138, 99.843, 160.44},
	{98.635, 97.199, 100.32, 157.12},
	{98.804, 97.31, 100.16, 153.11}
};
const double and4_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_1::power_op_ip2_rise[4][4] = {
	{101.13, 97.461, 103.38, 189.88},
	{95.735, 91.908, 97.073, 178.59},
	{94.256, 90.05, 94.797, 173.22},
	{92.592, 88.229, 92.482, 166.26}
};
const double and4_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_1::power_op_ip3_fall[4][4] = {
	{97.106, 96.114, 101.3, 169.47},
	{97.869, 96.138, 99.843, 160.44},
	{98.635, 97.199, 100.32, 157.12},
	{98.804, 97.31, 100.16, 153.11}
};
const double and4_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_1::power_op_ip3_rise[4][4] = {
	{101.13, 97.461, 103.38, 189.88},
	{95.735, 91.908, 97.073, 178.59},
	{94.256, 90.05, 94.797, 173.22},
	{92.592, 88.229, 92.482, 166.26}
};
const double and4_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_1::power_op_ip4_fall[4][4] = {
	{97.106, 96.114, 101.3, 169.47},
	{97.869, 96.138, 99.843, 160.44},
	{98.635, 97.199, 100.32, 157.12},
	{98.804, 97.31, 100.16, 153.11}
};
const double and4_1::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_1::power_op_ip4_rise[4][4] = {
	{101.13, 97.461, 103.38, 189.88},
	{95.735, 91.908, 97.073, 178.59},
	{94.256, 90.05, 94.797, 173.22},
	{92.592, 88.229, 92.482, 166.26}
};
const double and4_1::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double and4_1::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and4_2
// PROCESS NAME: proc
void and4_2::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

and4_2::~and4_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and4_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and4_2::celltype = "and4_2";
const double and4_2::leakage_power = 3.10063e-08;
const double and4_2::capacitance_ip1 = 10.955;
const double and4_2::fanout_load_ip1 = 2;
const double and4_2::capacitance_ip2 = 10.405;
const double and4_2::fanout_load_ip2 = 2;
const double and4_2::capacitance_ip3 = 10.031;
const double and4_2::fanout_load_ip3 = 2;
const double and4_2::capacitance_ip4 = 9.8227;
const double and4_2::fanout_load_ip4 = 2;
const double and4_2::max_capacitance_op = 250;
const double and4_2::max_fanout_op = 50;

const double and4_2::power_op_ip1_fall[4][4] = {
	{170.9, 168.96, 179.25, 308.95},
	{171.34, 168.3, 176.03, 295.59},
	{173.25, 170.13, 177.12, 289.39},
	{174.92, 171.92, 178.11, 281.32}
};
const double and4_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_2::power_op_ip1_rise[4][4] = {
	{173.18, 166.73, 178.87, 343.39},
	{167.2, 160.67, 171.59, 329.1},
	{164.79, 157.7, 167.79, 320.19},
	{162.55, 154.94, 163.54, 305.94}
};
const double and4_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_2::power_op_ip2_fall[4][4] = {
	{170.9, 168.96, 179.25, 308.95},
	{171.34, 168.3, 176.03, 295.59},
	{173.25, 170.13, 177.12, 289.39},
	{174.92, 171.92, 178.11, 281.32}
};
const double and4_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_2::power_op_ip2_rise[4][4] = {
	{173.18, 166.73, 178.87, 343.39},
	{167.2, 160.67, 171.59, 329.1},
	{164.79, 157.7, 167.79, 320.19},
	{162.55, 154.94, 163.54, 305.94}
};
const double and4_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_2::power_op_ip3_fall[4][4] = {
	{170.9, 168.96, 179.25, 308.95},
	{171.34, 168.3, 176.03, 295.59},
	{173.25, 170.13, 177.12, 289.39},
	{174.92, 171.92, 178.11, 281.32}
};
const double and4_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_2::power_op_ip3_rise[4][4] = {
	{173.18, 166.73, 178.87, 343.39},
	{167.2, 160.67, 171.59, 329.1},
	{164.79, 157.7, 167.79, 320.19},
	{162.55, 154.94, 163.54, 305.94}
};
const double and4_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_2::power_op_ip4_fall[4][4] = {
	{170.9, 168.96, 179.25, 308.95},
	{171.34, 168.3, 176.03, 295.59},
	{173.25, 170.13, 177.12, 289.39},
	{174.92, 171.92, 178.11, 281.32}
};
const double and4_2::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_2::power_op_ip4_rise[4][4] = {
	{173.18, 166.73, 178.87, 343.39},
	{167.2, 160.67, 171.59, 329.1},
	{164.79, 157.7, 167.79, 320.19},
	{162.55, 154.94, 163.54, 305.94}
};
const double and4_2::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double and4_2::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: and4_4
// PROCESS NAME: proc
void and4_4::proc()
{
	op.write(
		( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

and4_4::~and4_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void and4_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * and4_4::celltype = "and4_4";
const double and4_4::leakage_power = 4.92501e-08;
const double and4_4::capacitance_ip1 = 10.958;
const double and4_4::fanout_load_ip1 = 2;
const double and4_4::capacitance_ip2 = 10.295;
const double and4_4::fanout_load_ip2 = 2;
const double and4_4::capacitance_ip3 = 10.395;
const double and4_4::fanout_load_ip3 = 2;
const double and4_4::capacitance_ip4 = 9.6457;
const double and4_4::fanout_load_ip4 = 2;
const double and4_4::max_capacitance_op = 250;
const double and4_4::max_fanout_op = 50;

const double and4_4::power_op_ip1_fall[4][4] = {
	{243.52, 243.92, 259.55, 426.35},
	{235.11, 234.22, 246.7, 399.67},
	{233.72, 231.06, 240.94, 379.48},
	{236.79, 234.46, 240.53, 352.11}
};
const double and4_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_4::power_op_ip1_rise[4][4] = {
	{281.04, 276.74, 291.12, 483.16},
	{260.95, 256.02, 269.62, 455.06},
	{247.25, 241.86, 254.36, 431.06},
	{229.75, 223.26, 232.43, 386.4}
};
const double and4_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_4::power_op_ip2_fall[4][4] = {
	{243.52, 243.92, 259.55, 426.35},
	{235.11, 234.22, 246.7, 399.67},
	{233.72, 231.06, 240.94, 379.48},
	{236.79, 234.46, 240.53, 352.11}
};
const double and4_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_4::power_op_ip2_rise[4][4] = {
	{281.04, 276.74, 291.12, 483.16},
	{260.95, 256.02, 269.62, 455.06},
	{247.25, 241.86, 254.36, 431.06},
	{229.75, 223.26, 232.43, 386.4}
};
const double and4_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_4::power_op_ip3_fall[4][4] = {
	{243.52, 243.92, 259.55, 426.35},
	{235.11, 234.22, 246.7, 399.67},
	{233.72, 231.06, 240.94, 379.48},
	{236.79, 234.46, 240.53, 352.11}
};
const double and4_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_4::power_op_ip3_rise[4][4] = {
	{281.04, 276.74, 291.12, 483.16},
	{260.95, 256.02, 269.62, 455.06},
	{247.25, 241.86, 254.36, 431.06},
	{229.75, 223.26, 232.43, 386.4}
};
const double and4_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double and4_4::power_op_ip4_fall[4][4] = {
	{243.52, 243.92, 259.55, 426.35},
	{235.11, 234.22, 246.7, 399.67},
	{233.72, 231.06, 240.94, 379.48},
	{236.79, 234.46, 240.53, 352.11}
};
const double and4_4::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double and4_4::power_op_ip4_rise[4][4] = {
	{281.04, 276.74, 291.12, 483.16},
	{260.95, 256.02, 269.62, 455.06},
	{247.25, 241.86, 254.36, 431.06},
	{229.75, 223.26, 232.43, 386.4}
};
const double and4_4::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double and4_4::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: buf_1
// PROCESS NAME: proc
void buf_1::proc()
{
	op.write(
		ip.read() 
	);
}

buf_1::~buf_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void buf_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * buf_1::celltype = "buf_1";
const double buf_1::leakage_power = 4.037e-08;
const double buf_1::capacitance_ip = 4.8362;
const double buf_1::fanout_load_ip = 1;
const double buf_1::max_capacitance_op = 250;
const double buf_1::max_fanout_op = 50;

const double buf_1::power_op_ip_fall[4][4] = {
	{71.954, 72.332, 81.836, 168.5},
	{75.001, 74.312, 82.645, 162.4},
	{76.115, 75.807, 83.883, 161.59},
	{76.605, 76.574, 84.847, 160.65}
};
const double buf_1::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double buf_1::col_op_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double buf_1::power_op_ip_rise[4][4] = {
	{70.375, 71.58, 83.426, 193.47},
	{74.12, 72.908, 83.469, 186.79},
	{74.932, 74.287, 84.072, 184.14},
	{75.321, 75.19, 84.795, 182.27}
};
const double buf_1::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double buf_1::col_op_ip_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: buf_2
// PROCESS NAME: proc
void buf_2::proc()
{
	op.write(
		ip.read() 
	);
}

buf_2::~buf_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void buf_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * buf_2::celltype = "buf_2";
const double buf_2::leakage_power = 4.7932e-08;
const double buf_2::capacitance_ip = 9.6374;
const double buf_2::fanout_load_ip = 2;
const double buf_2::max_capacitance_op = 250;
const double buf_2::max_fanout_op = 50;

const double buf_2::power_op_ip_fall[4][4] = {
	{118.49, 118.92, 138.04, 304.74},
	{122.41, 121.16, 138.02, 295.12},
	{124.58, 123.25, 139.74, 292.8},
	{126.36, 125.8, 142.24, 290.67}
};
const double buf_2::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double buf_2::col_op_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double buf_2::power_op_ip_rise[4][4] = {
	{116.76, 118.74, 142.68, 355.15},
	{121.74, 120.78, 142.4, 346.93},
	{123.71, 122.16, 142.5, 341.73},
	{124.33, 123.22, 142.94, 334.33}
};
const double buf_2::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double buf_2::col_op_ip_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: buf_4
// PROCESS NAME: proc
void buf_4::proc()
{
	op.write(
		ip.read() 
	);
}

buf_4::~buf_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void buf_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * buf_4::celltype = "buf_4";
const double buf_4::leakage_power = 9.6338e-08;
const double buf_4::capacitance_ip = 20.444;
const double buf_4::fanout_load_ip = 4;
const double buf_4::max_capacitance_op = 250;
const double buf_4::max_fanout_op = 50;

const double buf_4::power_op_ip_fall[4][4] = {
	{189.81, 191.16, 232.3, 576.85},
	{195.43, 192.62, 229.59, 560.1},
	{199.86, 195.84, 231.84, 551.81},
	{206.6, 203.92, 238.81, 546.05}
};
const double buf_4::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double buf_4::col_op_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double buf_4::power_op_ip_rise[4][4] = {
	{186.04, 190.74, 243.83, 681.12},
	{193.76, 192.01, 242.06, 666.86},
	{199.99, 195.43, 242.73, 658.57},
	{203.19, 199.2, 243.43, 640.45}
};
const double buf_4::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double buf_4::col_op_ip_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: bufzp_2
// PROCESS NAME: proc
void bufzp_2::proc()
{
	op.write(
		ip.read() 
	);
}

bufzp_2::~bufzp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_c = c.get_interface();
	psc_objinfo_if *_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_c_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_fall[j]) {
					pts_op_c_fall[0].y = col_op_c_fall[j-1];
					pts_op_c_fall[0].x = lin_op_c_fall[i-1];
					pts_op_c_fall[0].z = power_op_c_fall[i-1][j-1];

					pts_op_c_fall[1].y = col_op_c_fall[j];
					pts_op_c_fall[1].x = lin_op_c_fall[i-1];
					pts_op_c_fall[1].z = power_op_c_fall[i-1][j];

					pts_op_c_fall[2].y = col_op_c_fall[j];
					pts_op_c_fall[2].x = lin_op_c_fall[i];
					pts_op_c_fall[2].z = power_op_c_fall[i][j];

					pts_op_c_fall[3].y = col_op_c_fall[j-1];
					pts_op_c_fall[3].x = lin_op_c_fall[i];
					pts_op_c_fall[3].z = power_op_c_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_fall = psc_geometric_centroid(pts_op_c_fall, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_c_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_rise[j]) {
					pts_op_c_rise[0].y = col_op_c_rise[j-1];
					pts_op_c_rise[0].x = lin_op_c_rise[i-1];
					pts_op_c_rise[0].z = power_op_c_rise[i-1][j-1];

					pts_op_c_rise[1].y = col_op_c_rise[j];
					pts_op_c_rise[1].x = lin_op_c_rise[i-1];
					pts_op_c_rise[1].z = power_op_c_rise[i-1][j];

					pts_op_c_rise[2].y = col_op_c_rise[j];
					pts_op_c_rise[2].x = lin_op_c_rise[i];
					pts_op_c_rise[2].z = power_op_c_rise[i][j];

					pts_op_c_rise[3].y = col_op_c_rise[j-1];
					pts_op_c_rise[3].x = lin_op_c_rise[i];
					pts_op_c_rise[3].z = power_op_c_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_rise = psc_geometric_centroid(pts_op_c_rise, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_c_fall(_p_op->get_id(), E_op_c_fall);
	pwr_op_c_fall.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_fall);
	psc_pin_power_info pwr_op_c_rise(_p_op->get_id(), E_op_c_rise);
	pwr_op_c_rise.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_rise);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void bufzp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_c, delay_c, wres_c, wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_c, *_if_ip, *_if_op;
	psc_objinfo_if *_p_c, *_p_ip, *_p_op;

	_if_c = c.get_interface();
	_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);
	wcap_c = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_c->get_fanout()-1];
	_p_c->set_wire_load(wcap_c);
	wres_c = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_c->get_fanout()-1] * 1e3;
	delay_c = (wres_c/(double)_p_c->get_fanout())*((wcap_c/(double)_p_c->get_fanout()) + capacitance_c);
	_p_c->add_to_net_load(capacitance_c);
	_p_c->set_net_delay(delay_c);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * bufzp_2::celltype = "bufzp_2";
const double bufzp_2::leakage_power = 6.3191e-08;
const double bufzp_2::capacitance_c = 6.8761;
const double bufzp_2::fanout_load_c = 1;
const double bufzp_2::capacitance_ip = 4.9294;
const double bufzp_2::fanout_load_ip = 1;
const double bufzp_2::max_capacitance_op = 250;
const double bufzp_2::max_fanout_op = 50;

const double bufzp_2::power_op_c_fall[4][4] = {
	{78.132, 78.614, 78.932, 89.66},
	{79.129, 79.634, 79.925, 85.839},
	{79.782, 80.634, 80.657, 84.562},
	{79.937, 80.815, 80.726, 82.079}
};
const double bufzp_2::lin_op_c_fall[4] = {0, 20, 50, 250};
const double bufzp_2::col_op_c_fall[4] = {0, 66.037, 144.95, 672.54};

const double bufzp_2::power_op_c_rise[4][4] = {
	{65, 65.469, 65.803, 79.792},
	{66.619, 66.685, 66.695, 75.074},
	{67.09, 67.487, 66.983, 72.151},
	{67.486, 67.675, 67.512, 68.673}
};
const double bufzp_2::lin_op_c_rise[4] = {0, 20, 50, 250};
const double bufzp_2::col_op_c_rise[4] = {0, 59.722, 125.27, 578.29};

const double bufzp_2::power_op_ip_fall[4][4] = {
	{78.132, 78.614, 78.932, 89.66},
	{79.129, 79.634, 79.925, 85.839},
	{79.782, 80.634, 80.657, 84.562},
	{79.937, 80.815, 80.726, 82.079}
};
const double bufzp_2::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double bufzp_2::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double bufzp_2::power_op_ip_rise[4][4] = {
	{65, 65.469, 65.803, 79.792},
	{66.619, 66.685, 66.695, 75.074},
	{67.09, 67.487, 66.983, 72.151},
	{67.486, 67.675, 67.512, 68.673}
};
const double bufzp_2::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double bufzp_2::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: cd_12
// PROCESS NAME: proc
void cd_12::proc()
{
	op.write(
		ip.read() 
	);
}

cd_12::~cd_12()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void cd_12::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * cd_12::celltype = "cd_12";
const double cd_12::leakage_power = 2.8759e-07;
const double cd_12::capacitance_ip = 20.022;
const double cd_12::fanout_load_ip = 4;
const double cd_12::max_capacitance_op = 5000;
const double cd_12::max_fanout_op = 1000;

const double cd_12::power_op_ip_fall[4][4] = {
	{657.83, 655.66, 692.17, 1462.8},
	{673.56, 671.27, 707.8, 1478.5},
	{673.84, 671.55, 708.08, 1478.8},
	{673.51, 671.22, 707.74, 1478.5}
};
const double cd_12::lin_op_ip_fall[4] = {0, 200, 1000, 5000};
const double cd_12::col_op_ip_fall[4] = {0, 59.708, 125.23, 1146.3};

const double cd_12::power_op_ip_rise[4][4] = {
	{654.71, 653.05, 701.88, 1671},
	{669.57, 668.09, 717.31, 1686},
	{669.69, 667.87, 717.32, 1686.1},
	{668.34, 666.24, 715.88, 1684}
};
const double cd_12::lin_op_ip_rise[4] = {0, 200, 1000, 5000};
const double cd_12::col_op_ip_rise[4] = {0, 59.708, 125.23, 1146.3};

// MODULE: cd_16
// PROCESS NAME: proc
void cd_16::proc()
{
	op.write(
		ip.read() 
	);
}

cd_16::~cd_16()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void cd_16::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * cd_16::celltype = "cd_16";
const double cd_16::leakage_power = 3.8346e-07;
const double cd_16::capacitance_ip = 20.022;
const double cd_16::fanout_load_ip = 4;
const double cd_16::max_capacitance_op = 5000;
const double cd_16::max_fanout_op = 1000;

const double cd_16::power_op_ip_fall[4][4] = {
	{903.26, 901.21, 937.6, 1708.1},
	{919.39, 917.27, 953.66, 1724.2},
	{919.81, 917.72, 954.11, 1724.7},
	{919.52, 917.43, 953.82, 1724.4}
};
const double cd_16::lin_op_ip_fall[4] = {0, 200, 1000, 5000};
const double cd_16::col_op_ip_fall[4] = {0, 59.708, 125.23, 1146.3};

const double cd_16::power_op_ip_rise[4][4] = {
	{900.45, 898.32, 947.89, 1916.2},
	{915.95, 913.86, 962.71, 1932},
	{916.24, 914.18, 963.63, 1932.1},
	{914.92, 912.79, 962.21, 1930}
};
const double cd_16::lin_op_ip_rise[4] = {0, 200, 1000, 5000};
const double cd_16::col_op_ip_rise[4] = {0, 59.708, 125.23, 1146.3};

// MODULE: cd_8
// PROCESS NAME: proc
void cd_8::proc()
{
	op.write(
		ip.read() 
	);
}

cd_8::~cd_8()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void cd_8::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * cd_8::celltype = "cd_8";
const double cd_8::leakage_power = 1.9173e-07;
const double cd_8::capacitance_ip = 20.059;
const double cd_8::fanout_load_ip = 4;
const double cd_8::max_capacitance_op = 5000;
const double cd_8::max_fanout_op = 1000;

const double cd_8::power_op_ip_fall[4][4] = {
	{425.94, 423.38, 459.95, 1231.4},
	{441.52, 438.91, 475.41, 1246.2},
	{441.82, 439.44, 475.95, 1246.9},
	{441.49, 439.15, 475.65, 1246.7}
};
const double cd_8::lin_op_ip_fall[4] = {0, 200, 1000, 5000};
const double cd_8::col_op_ip_fall[4] = {0, 59.708, 125.23, 1146.3};

const double cd_8::power_op_ip_rise[4][4] = {
	{422.61, 420.88, 470.76, 1440.2},
	{437.46, 435.57, 485.43, 1452.5},
	{437.58, 435.73, 485.61, 1453.3},
	{436.24, 434.34, 484.21, 1451.4}
};
const double cd_8::lin_op_ip_rise[4] = {0, 200, 1000, 5000};
const double cd_8::col_op_ip_rise[4] = {0, 59.708, 125.23, 1146.3};

// MODULE: dksp_1
// PROCESS NAME: proc
void dksp_1::proc()
{
	q.write(
		IQ.read() 
	);
	qb.write(
		IQN.read() 
	);
}

// MODULE: dksp_1
// PROCESS NAME: ff_input
void dksp_1::ff_input()
{
	bool _next_ = ip.read() | ! sb.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);
}

dksp_1::~dksp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_sb = sb.get_interface();
	psc_objinfo_if *_p_sb = dynamic_cast<psc_objinfo_if*>(_if_sb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	sc_interface *_if_qb = qb.get_interface();
	psc_objinfo_if *_p_qb = dynamic_cast<psc_objinfo_if*>(_if_qb);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_sb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_sb->get_net_delay() < col_sb_fall[j]) {
			pts_sb_fall[0].x = col_sb_fall[j-1];
			pts_sb_fall[0].y = power_sb_fall[j-1];

			pts_sb_fall[1].x = col_sb_fall[j];
			pts_sb_fall[1].y = power_sb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_sb_fall = psc_weighted_average(pts_sb_fall, _p_sb->get_net_delay());

	psc_point_t pts_sb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_sb->get_net_delay() < col_sb_rise[j]) {
			pts_sb_rise[0].x = col_sb_rise[j-1];
			pts_sb_rise[0].y = power_sb_rise[j-1];

			pts_sb_rise[1].x = col_sb_rise[j];
			pts_sb_rise[1].y = power_sb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_sb_rise = psc_weighted_average(pts_sb_rise, _p_sb->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_sb_fall(_p_sb->get_id(), E_sb_fall);
	pwr_sb_fall.set_rel_pins(1, _p_sb->get_id().c_str());
	info.add(pwr_sb_fall);
	psc_pin_power_info pwr_sb_rise(_p_sb->get_id(), E_sb_rise);
	pwr_sb_rise.set_rel_pins(1, _p_sb->get_id().c_str());
	info.add(pwr_sb_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void dksp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_sb, delay_sb, wres_sb, wcap_q, wcap_qb;
	sc_interface *_if_ck, *_if_ip, *_if_sb, *_if_q, *_if_qb;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_sb, *_p_q, *_p_qb;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_sb = sb.get_interface();
	_p_sb = dynamic_cast<psc_objinfo_if*>(_if_sb);
	wcap_sb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_sb->get_fanout()-1];
	_p_sb->set_wire_load(wcap_sb);
	wres_sb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_sb->get_fanout()-1] * 1e3;
	delay_sb = (wres_sb/(double)_p_sb->get_fanout())*((wcap_sb/(double)_p_sb->get_fanout()) + capacitance_sb);
	_p_sb->add_to_net_load(capacitance_sb);
	_p_sb->set_net_delay(delay_sb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);

	_if_qb = qb.get_interface();
	_p_qb = dynamic_cast<psc_objinfo_if*>(_if_qb);
	wcap_qb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_qb->get_fanout()-1];
	_p_qb->set_wire_load(wcap_qb);
#endif
}
const char * dksp_1::celltype = "dksp_1";
const double dksp_1::leakage_power = 4.39336e-07;
const double dksp_1::capacitance_ck = 5.2337;
const double dksp_1::fanout_load_ck = 1;
const double dksp_1::capacitance_ip = 4.8388;
const double dksp_1::fanout_load_ip = 1;
const double dksp_1::capacitance_sb = 5.3137;
const double dksp_1::fanout_load_sb = 1;
const double dksp_1::max_capacitance_q = 250;
const double dksp_1::max_fanout_q = 50;
const double dksp_1::max_capacitance_qb = 0.6;
const double dksp_1::max_fanout_qb = 100;

const double dksp_1::power_ck_fall[4] = {
	133.43, 220.88, 228.58, 311.6
};
const double dksp_1::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dksp_1::power_ck_rise[4] = {
	131.07, 131.59, 141.28, 242.98
};
const double dksp_1::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dksp_1::power_ip_fall[4] = {
	0.0045495, 162.6, 171.27, 251.99
};
const double dksp_1::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dksp_1::power_ip_rise[4] = {
	0.0045495, 168.49, 179, 283.97
};
const double dksp_1::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dksp_1::power_sb_fall[4] = {
	0.17637, 0.20022, 0.20002, 0.19986
};
const double dksp_1::col_sb_fall[4] = {0, 59.722, 125.27, 578.29};

const double dksp_1::power_sb_rise[4] = {
	0.17621, 0.19994, 0.19971, 0.19953
};
const double dksp_1::col_sb_rise[4] = {0, 66.037, 144.95, 672.54};

const double dksp_1::power_q_ck_fall[4][4] = {
	{1.121e-09, 279.91, 281.94, 289.85},
	{0, 277.45, 279.4, 287.41},
	{0, 278.7, 280.81, 288.19},
	{0, 279.47, 281.52, 289.75}
};
const double dksp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double dksp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dksp_1::power_q_ck_rise[4][4] = {
	{3.1739e-10, 290.04, 291.15, 296.93},
	{0, 288.72, 289.81, 295.58},
	{0, 288.28, 289.42, 295.12},
	{0, 287.92, 289.04, 294.83}
};
const double dksp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double dksp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: dp_1
// PROCESS NAME: proc
void dp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: dp_1
// PROCESS NAME: ff_input
void dp_1::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);
}

dp_1::~dp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void dp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * dp_1::celltype = "dp_1";
const double dp_1::leakage_power = 3.20183e-06;
const double dp_1::capacitance_ck = 14.859;
const double dp_1::fanout_load_ck = 3;
const double dp_1::capacitance_ip = 4.583;
const double dp_1::fanout_load_ip = 1;
const double dp_1::max_capacitance_q = 250;
const double dp_1::max_fanout_q = 50;

const double dp_1::power_ck_fall[4] = {
	133.39, 127.76, 135.71, 223.89
};
const double dp_1::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_1::power_ck_rise[4] = {
	64.454, 59.353, 66.436, 158.97
};
const double dp_1::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_1::power_ip_fall[4] = {
	78.875, 76.322, 77.364, 109.09
};
const double dp_1::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_1::power_ip_rise[4] = {
	81.103, 78.48, 80.738, 123.23
};
const double dp_1::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_1::power_q_ck_fall[4][4] = {
	{129.83, 129.91, 131.03, 136.27},
	{127.35, 127.52, 128.78, 134.27},
	{127.38, 127.33, 128.4, 134.04},
	{126.87, 127.02, 128.03, 133.44}
};
const double dp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double dp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_1::power_q_ck_rise[4][4] = {
	{103.51, 103, 110.98, 178.89},
	{104.67, 103, 108.89, 176.5},
	{105.34, 103.53, 108.52, 176.32},
	{105.88, 104.31, 109.22, 172.36}
};
const double dp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double dp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: dp_2
// PROCESS NAME: proc
void dp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: dp_2
// PROCESS NAME: ff_input
void dp_2::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);
}

dp_2::~dp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void dp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * dp_2::celltype = "dp_2";
const double dp_2::leakage_power = 3.25371e-06;
const double dp_2::capacitance_ck = 15.306;
const double dp_2::fanout_load_ck = 3;
const double dp_2::capacitance_ip = 4.6016;
const double dp_2::fanout_load_ip = 1;
const double dp_2::max_capacitance_q = 250;
const double dp_2::max_fanout_q = 50;

const double dp_2::power_ck_fall[4] = {
	133.85, 128.15, 136.14, 224.15
};
const double dp_2::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_2::power_ck_rise[4] = {
	64.561, 59.61, 66.712, 159.08
};
const double dp_2::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_2::power_ip_fall[4] = {
	79.057, 76.525, 77.529, 109.24
};
const double dp_2::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_2::power_ip_rise[4] = {
	81.285, 78.591, 80.912, 123.39
};
const double dp_2::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_2::power_q_ck_fall[4][4] = {
	{180.79, 180.43, 180.47, 185.8},
	{171.3, 169.77, 170.2, 175.73},
	{166.18, 166.39, 166.75, 172.2},
	{161.99, 162.38, 163, 167.93}
};
const double dp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double dp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_2::power_q_ck_rise[4][4] = {
	{139.52, 141.23, 151.67, 241.77},
	{137.38, 137.56, 145.75, 229.08},
	{137.2, 136.53, 143.15, 222.12},
	{137.1, 136.17, 140.43, 207.93}
};
const double dp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double dp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: dp_4
// PROCESS NAME: proc
void dp_4::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: dp_4
// PROCESS NAME: ff_input
void dp_4::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);
}

dp_4::~dp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void dp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * dp_4::celltype = "dp_4";
const double dp_4::leakage_power = 3.3029e-06;
const double dp_4::capacitance_ck = 15.088;
const double dp_4::fanout_load_ck = 3;
const double dp_4::capacitance_ip = 4.648;
const double dp_4::fanout_load_ip = 1;
const double dp_4::max_capacitance_q = 250;
const double dp_4::max_fanout_q = 50;

const double dp_4::power_ck_fall[4] = {
	132.97, 127.95, 135.7, 223.83
};
const double dp_4::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_4::power_ck_rise[4] = {
	63.82, 59.256, 66.452, 158.91
};
const double dp_4::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_4::power_ip_fall[4] = {
	78.898, 76.186, 77.364, 109.07
};
const double dp_4::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_4::power_ip_rise[4] = {
	81.103, 78.298, 80.73, 123.23
};
const double dp_4::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dp_4::power_q_ck_fall[4][4] = {
	{322.03, 319.59, 320.83, 321.46},
	{296.83, 297.23, 295.44, 298.4},
	{273.2, 273.09, 274.44, 274.37},
	{238.87, 239.01, 239.24, 242.27}
};
const double dp_4::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double dp_4::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dp_4::power_q_ck_rise[4][4] = {
	{234.25, 239.32, 257.14, 403.87},
	{216.73, 221.19, 236.5, 371.22},
	{206.94, 210.29, 223.18, 345.28},
	{195.58, 196.22, 202.95, 294.83}
};
const double dp_4::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double dp_4::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drp_1
// PROCESS NAME: proc
void drp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drp_1
// PROCESS NAME: ff_input
void drp_1::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
}

drp_1::~drp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drp_1::celltype = "drp_1";
const double drp_1::leakage_power = 3.3693e-06;
const double drp_1::capacitance_ck = 15.433;
const double drp_1::fanout_load_ck = 3;
const double drp_1::capacitance_ip = 4.5979;
const double drp_1::fanout_load_ip = 1;
const double drp_1::capacitance_rb = 14.121;
const double drp_1::fanout_load_rb = 3;
const double drp_1::max_capacitance_q = 250;
const double drp_1::max_fanout_q = 50;

const double drp_1::power_ck_fall[4] = {
	152.97, 147.34, 154.64, 240.42
};
const double drp_1::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_1::power_ck_rise[4] = {
	66.038, 61.035, 68.021, 160.03
};
const double drp_1::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_1::power_ip_fall[4] = {
	89.933, 87.239, 87.557, 117.33
};
const double drp_1::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_1::power_ip_rise[4] = {
	92.629, 89.688, 90.874, 130.67
};
const double drp_1::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_1::power_rb_fall[4] = {
	75.205, 68.109, 67.272, 105.58
};
const double drp_1::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_1::power_rb_rise[4] = {
	48.749, 46.282, 46.774, 64.827
};
const double drp_1::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_1::power_q_ck_fall[4][4] = {
	{146.2, 146.29, 147.49, 152.5},
	{142.77, 143.49, 144.61, 149.94},
	{142.4, 142.74, 143.97, 149.29},
	{141.62, 142, 143.21, 148.37}
};
const double drp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_1::power_q_ck_rise[4][4] = {
	{124.02, 124.01, 131.86, 200.96},
	{125.12, 123.93, 130.15, 198.24},
	{125.89, 124.51, 130, 197.44},
	{126.36, 125.14, 130.45, 192.91}
};
const double drp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_1::power_q_rb_fall[4][4] = {
	{146.2, 146.29, 147.49, 152.5},
	{142.77, 143.49, 144.61, 149.94},
	{142.4, 142.74, 143.97, 149.29},
	{141.62, 142, 143.21, 148.37}
};
const double drp_1::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drp_1::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_1::power_q_rb_rise[4][4] = {
	{124.02, 124.01, 131.86, 200.96},
	{125.12, 123.93, 130.15, 198.24},
	{125.89, 124.51, 130, 197.44},
	{126.36, 125.14, 130.45, 192.91}
};
const double drp_1::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drp_1::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drp_2
// PROCESS NAME: proc
void drp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drp_2
// PROCESS NAME: ff_input
void drp_2::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
}

drp_2::~drp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drp_2::celltype = "drp_2";
const double drp_2::leakage_power = 4.02895e-06;
const double drp_2::capacitance_ck = 15.434;
const double drp_2::fanout_load_ck = 3;
const double drp_2::capacitance_ip = 4.6015;
const double drp_2::fanout_load_ip = 1;
const double drp_2::capacitance_rb = 14.394;
const double drp_2::fanout_load_rb = 3;
const double drp_2::max_capacitance_q = 250;
const double drp_2::max_fanout_q = 50;

const double drp_2::power_ck_fall[4] = {
	158.14, 152.85, 160.42, 245.06
};
const double drp_2::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_2::power_ck_rise[4] = {
	65.715, 61.004, 68.025, 160.02
};
const double drp_2::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_2::power_ip_fall[4] = {
	89.96, 87.276, 87.588, 117.34
};
const double drp_2::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_2::power_ip_rise[4] = {
	92.611, 89.67, 90.856, 130.66
};
const double drp_2::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_2::power_rb_fall[4] = {
	74.04, 67.572, 66.945, 107.56
};
const double drp_2::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_2::power_rb_rise[4] = {
	49.884, 47.416, 47.946, 65.911
};
const double drp_2::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_2::power_q_ck_fall[4][4] = {
	{215.21, 214.38, 215.21, 220.15},
	{205.86, 205.8, 206.59, 211.52},
	{202.48, 202.32, 203.05, 208.24},
	{197.74, 197.62, 198.92, 203.68}
};
const double drp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_2::power_q_ck_rise[4][4] = {
	{177.16, 178.48, 189.1, 289.86},
	{175.55, 175.83, 184.64, 279.1},
	{175.6, 174.96, 182.31, 272.14},
	{175.82, 174.59, 180.21, 255.78}
};
const double drp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_2::power_q_rb_fall[4][4] = {
	{215.21, 214.38, 215.21, 220.15},
	{205.86, 205.8, 206.59, 211.52},
	{202.48, 202.32, 203.05, 208.24},
	{197.74, 197.62, 198.92, 203.68}
};
const double drp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_2::power_q_rb_rise[4][4] = {
	{177.16, 178.48, 189.1, 289.86},
	{175.55, 175.83, 184.64, 279.1},
	{175.6, 174.96, 182.31, 272.14},
	{175.82, 174.59, 180.21, 255.78}
};
const double drp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drp_4
// PROCESS NAME: proc
void drp_4::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drp_4
// PROCESS NAME: ff_input
void drp_4::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
}

drp_4::~drp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drp_4::celltype = "drp_4";
const double drp_4::leakage_power = 4.35507e-06;
const double drp_4::capacitance_ck = 15.5;
const double drp_4::fanout_load_ck = 3;
const double drp_4::capacitance_ip = 4.594;
const double drp_4::fanout_load_ip = 1;
const double drp_4::capacitance_rb = 14.323;
const double drp_4::fanout_load_rb = 3;
const double drp_4::max_capacitance_q = 250;
const double drp_4::max_fanout_q = 50;

const double drp_4::power_ck_fall[4] = {
	158.24, 153.14, 160.77, 245.45
};
const double drp_4::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_4::power_ck_rise[4] = {
	65.419, 60.972, 68.035, 160.02
};
const double drp_4::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_4::power_ip_fall[4] = {
	90.044, 87.363, 87.673, 117.35
};
const double drp_4::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_4::power_ip_rise[4] = {
	92.639, 89.728, 90.914, 130.72
};
const double drp_4::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_4::power_rb_fall[4] = {
	71.546, 65.238, 65.777, 111.68
};
const double drp_4::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_4::power_rb_rise[4] = {
	49.945, 47.466, 47.988, 65.979
};
const double drp_4::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_4::power_q_ck_fall[4][4] = {
	{351.24, 349.67, 350.65, 352.44},
	{329.81, 329.8, 329.14, 331.02},
	{306.99, 308.5, 306.65, 308.56},
	{273.96, 274.5, 274.69, 277.41}
};
const double drp_4::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drp_4::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_4::power_q_ck_rise[4][4] = {
	{266.26, 270.9, 288.88, 445.95},
	{251.47, 255.58, 271.33, 415.58},
	{243.28, 246.28, 259.87, 390.71},
	{233.13, 233.52, 241.48, 340.64}
};
const double drp_4::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drp_4::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drp_4::power_q_rb_fall[4][4] = {
	{351.24, 349.67, 350.65, 352.44},
	{329.81, 329.8, 329.14, 331.02},
	{306.99, 308.5, 306.65, 308.56},
	{273.96, 274.5, 274.69, 277.41}
};
const double drp_4::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drp_4::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drp_4::power_q_rb_rise[4][4] = {
	{266.26, 270.9, 288.88, 445.95},
	{251.47, 255.58, 271.33, 415.58},
	{243.28, 246.28, 259.87, 390.71},
	{233.13, 233.52, 241.48, 340.64}
};
const double drp_4::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drp_4::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drsp_1
// PROCESS NAME: proc
void drsp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drsp_1
// PROCESS NAME: ff_input
void drsp_1::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

drsp_1::~drsp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_s_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_fall[j]) {
			pts_s_fall[0].x = col_s_fall[j-1];
			pts_s_fall[0].y = power_s_fall[j-1];

			pts_s_fall[1].x = col_s_fall[j];
			pts_s_fall[1].y = power_s_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_fall = psc_weighted_average(pts_s_fall, _p_s->get_net_delay());

	psc_point_t pts_s_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_rise[j]) {
			pts_s_rise[0].x = col_s_rise[j-1];
			pts_s_rise[0].y = power_s_rise[j-1];

			pts_s_rise[1].x = col_s_rise[j];
			pts_s_rise[1].y = power_s_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_rise = psc_weighted_average(pts_s_rise, _p_s->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_s_fall(_p_s->get_id(), E_s_fall);
	pwr_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_fall);
	psc_pin_power_info pwr_s_rise(_p_s->get_id(), E_s_rise);
	pwr_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drsp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drsp_1::celltype = "drsp_1";
const double drsp_1::leakage_power = 3.45514e-06;
const double drsp_1::capacitance_ck = 15.577;
const double drsp_1::fanout_load_ck = 3;
const double drsp_1::capacitance_ip = 4.7424;
const double drsp_1::fanout_load_ip = 1;
const double drsp_1::capacitance_rb = 14.458;
const double drsp_1::fanout_load_rb = 3;
const double drsp_1::capacitance_s = 15.601;
const double drsp_1::fanout_load_s = 3;
const double drsp_1::max_capacitance_q = 250;
const double drsp_1::max_fanout_q = 50;

const double drsp_1::power_ck_fall[4] = {
	176.75, 170.2, 176.89, 257.51
};
const double drsp_1::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_ck_rise[4] = {
	67.955, 63.125, 70.118, 161.28
};
const double drsp_1::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_ip_fall[4] = {
	112.35, 109.32, 108.47, 132.13
};
const double drsp_1::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_ip_rise[4] = {
	108.94, 105.47, 105.87, 139.77
};
const double drsp_1::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_rb_fall[4] = {
	79.466, 74.14, 72.924, 105.66
};
const double drsp_1::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_rb_rise[4] = {
	55.611, 53.348, 53.6, 70.913
};
const double drsp_1::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_s_fall[4] = {
	55.938, 54.713, 54.397, 63.849
};
const double drsp_1::col_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_s_rise[4] = {
	97.966, 90.221, 87.999, 101.27
};
const double drsp_1::col_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_q_ck_fall[4][4] = {
	{159.74, 159.09, 160.15, 166.38},
	{157.03, 156.33, 157, 164.09},
	{156.26, 155.97, 156.57, 163.42},
	{155.31, 154.74, 155.55, 162.29}
};
const double drsp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drsp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_q_ck_rise[4][4] = {
	{139.08, 140.21, 146.18, 202.73},
	{140.17, 140.44, 144.95, 199.22},
	{140.87, 141.04, 144.9, 198.05},
	{141.28, 141.61, 145.24, 194.46}
};
const double drsp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drsp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_q_rb_fall[4][4] = {
	{159.74, 159.09, 160.15, 166.38},
	{157.03, 156.33, 157, 164.09},
	{156.26, 155.97, 156.57, 163.42},
	{155.31, 154.74, 155.55, 162.29}
};
const double drsp_1::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drsp_1::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_q_rb_rise[4][4] = {
	{139.08, 140.21, 146.18, 202.73},
	{140.17, 140.44, 144.95, 199.22},
	{140.87, 141.04, 144.9, 198.05},
	{141.28, 141.61, 145.24, 194.46}
};
const double drsp_1::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drsp_1::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_1::power_q_s_fall[4][4] = {
	{159.74, 159.09, 160.15, 166.38},
	{157.03, 156.33, 157, 164.09},
	{156.26, 155.97, 156.57, 163.42},
	{155.31, 154.74, 155.55, 162.29}
};
const double drsp_1::lin_q_s_fall[4] = {0, 20, 50, 250};
const double drsp_1::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_1::power_q_s_rise[4][4] = {
	{139.08, 140.21, 146.18, 202.73},
	{140.17, 140.44, 144.95, 199.22},
	{140.87, 141.04, 144.9, 198.05},
	{141.28, 141.61, 145.24, 194.46}
};
const double drsp_1::lin_q_s_rise[4] = {0, 20, 50, 250};
const double drsp_1::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drsp_2
// PROCESS NAME: proc
void drsp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drsp_2
// PROCESS NAME: ff_input
void drsp_2::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

drsp_2::~drsp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_s_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_fall[j]) {
			pts_s_fall[0].x = col_s_fall[j-1];
			pts_s_fall[0].y = power_s_fall[j-1];

			pts_s_fall[1].x = col_s_fall[j];
			pts_s_fall[1].y = power_s_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_fall = psc_weighted_average(pts_s_fall, _p_s->get_net_delay());

	psc_point_t pts_s_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_rise[j]) {
			pts_s_rise[0].x = col_s_rise[j-1];
			pts_s_rise[0].y = power_s_rise[j-1];

			pts_s_rise[1].x = col_s_rise[j];
			pts_s_rise[1].y = power_s_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_rise = psc_weighted_average(pts_s_rise, _p_s->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_s_fall(_p_s->get_id(), E_s_fall);
	pwr_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_fall);
	psc_pin_power_info pwr_s_rise(_p_s->get_id(), E_s_rise);
	pwr_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drsp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drsp_2::celltype = "drsp_2";
const double drsp_2::leakage_power = 4.02801e-06;
const double drsp_2::capacitance_ck = 15.677;
const double drsp_2::fanout_load_ck = 3;
const double drsp_2::capacitance_ip = 4.7372;
const double drsp_2::fanout_load_ip = 1;
const double drsp_2::capacitance_rb = 14.6;
const double drsp_2::fanout_load_rb = 3;
const double drsp_2::capacitance_s = 19.244;
const double drsp_2::fanout_load_s = 4;
const double drsp_2::max_capacitance_q = 250;
const double drsp_2::max_fanout_q = 50;

const double drsp_2::power_ck_fall[4] = {
	192.67, 185.23, 190.22, 269.58
};
const double drsp_2::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_ck_rise[4] = {
	67.607, 63.042, 70.124, 161.27
};
const double drsp_2::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_ip_fall[4] = {
	112.45, 109.4, 108.57, 132.22
};
const double drsp_2::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_ip_rise[4] = {
	109, 105.53, 105.91, 139.83
};
const double drsp_2::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_rb_fall[4] = {
	78.02, 73.5, 72.891, 106.97
};
const double drsp_2::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_rb_rise[4] = {
	56.665, 54.559, 54.904, 72.158
};
const double drsp_2::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_s_fall[4] = {
	57.896, 56.6, 56.482, 65.524
};
const double drsp_2::col_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_s_rise[4] = {
	109.1, 98.008, 94.507, 106.33
};
const double drsp_2::col_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_q_ck_fall[4][4] = {
	{237.16, 235.74, 237.39, 242.56},
	{229.98, 227.61, 228.11, 234.66},
	{225.04, 224.05, 224.54, 230.82},
	{219.75, 219.35, 219.28, 225.71}
};
const double drsp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drsp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_q_ck_rise[4][4] = {
	{194.1, 196.24, 205.76, 297.71},
	{192.62, 193.77, 201.4, 286.85},
	{192.58, 192.86, 199.42, 279.16},
	{192.75, 192.79, 197.06, 263.2}
};
const double drsp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drsp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_q_rb_fall[4][4] = {
	{237.16, 235.74, 237.39, 242.56},
	{229.98, 227.61, 228.11, 234.66},
	{225.04, 224.05, 224.54, 230.82},
	{219.75, 219.35, 219.28, 225.71}
};
const double drsp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drsp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_q_rb_rise[4][4] = {
	{194.1, 196.24, 205.76, 297.71},
	{192.62, 193.77, 201.4, 286.85},
	{192.58, 192.86, 199.42, 279.16},
	{192.75, 192.79, 197.06, 263.2}
};
const double drsp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drsp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_2::power_q_s_fall[4][4] = {
	{237.16, 235.74, 237.39, 242.56},
	{229.98, 227.61, 228.11, 234.66},
	{225.04, 224.05, 224.54, 230.82},
	{219.75, 219.35, 219.28, 225.71}
};
const double drsp_2::lin_q_s_fall[4] = {0, 20, 50, 250};
const double drsp_2::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_2::power_q_s_rise[4][4] = {
	{194.1, 196.24, 205.76, 297.71},
	{192.62, 193.77, 201.4, 286.85},
	{192.58, 192.86, 199.42, 279.16},
	{192.75, 192.79, 197.06, 263.2}
};
const double drsp_2::lin_q_s_rise[4] = {0, 20, 50, 250};
const double drsp_2::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: drsp_4
// PROCESS NAME: proc
void drsp_4::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: drsp_4
// PROCESS NAME: ff_input
void drsp_4::ff_input()
{
	bool _next_ = ip.read() ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

drsp_4::~drsp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_s_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_fall[j]) {
			pts_s_fall[0].x = col_s_fall[j-1];
			pts_s_fall[0].y = power_s_fall[j-1];

			pts_s_fall[1].x = col_s_fall[j];
			pts_s_fall[1].y = power_s_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_fall = psc_weighted_average(pts_s_fall, _p_s->get_net_delay());

	psc_point_t pts_s_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_rise[j]) {
			pts_s_rise[0].x = col_s_rise[j-1];
			pts_s_rise[0].y = power_s_rise[j-1];

			pts_s_rise[1].x = col_s_rise[j];
			pts_s_rise[1].y = power_s_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_rise = psc_weighted_average(pts_s_rise, _p_s->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_s_fall(_p_s->get_id(), E_s_fall);
	pwr_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_fall);
	psc_pin_power_info pwr_s_rise(_p_s->get_id(), E_s_rise);
	pwr_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void drsp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * drsp_4::celltype = "drsp_4";
const double drsp_4::leakage_power = 4.21985e-06;
const double drsp_4::capacitance_ck = 15.691;
const double drsp_4::fanout_load_ck = 3;
const double drsp_4::capacitance_ip = 4.7607;
const double drsp_4::fanout_load_ip = 1;
const double drsp_4::capacitance_rb = 14.614;
const double drsp_4::fanout_load_rb = 3;
const double drsp_4::capacitance_s = 19.272;
const double drsp_4::fanout_load_s = 4;
const double drsp_4::max_capacitance_q = 250;
const double drsp_4::max_fanout_q = 50;

const double drsp_4::power_ck_fall[4] = {
	190.6, 184.23, 190.71, 270.31
};
const double drsp_4::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_ck_rise[4] = {
	67.347, 63.04, 70.154, 161.27
};
const double drsp_4::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_ip_fall[4] = {
	112.44, 109.2, 108.55, 132.21
};
const double drsp_4::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_ip_rise[4] = {
	108.98, 105.52, 105.9, 139.79
};
const double drsp_4::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_rb_fall[4] = {
	76.643, 72.403, 72.212, 111.85
};
const double drsp_4::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_rb_rise[4] = {
	56.723, 54.567, 54.928, 72.191
};
const double drsp_4::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_s_fall[4] = {
	57.879, 56.595, 56.372, 65.524
};
const double drsp_4::col_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_s_rise[4] = {
	117, 104.23, 97.889, 94.544
};
const double drsp_4::col_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_q_ck_fall[4][4] = {
	{375.84, 375.17, 372.99, 377.35},
	{353.91, 352.02, 351.18, 354.7},
	{331.38, 331.17, 328.81, 331.67},
	{295.83, 294.93, 294.65, 299.29}
};
const double drsp_4::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double drsp_4::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_q_ck_rise[4][4] = {
	{282.76, 288.46, 305.39, 452.47},
	{268.23, 273.11, 287.65, 421.97},
	{259.78, 263.65, 276.3, 398.1},
	{249.59, 250.94, 258, 348.36}
};
const double drsp_4::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double drsp_4::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_q_rb_fall[4][4] = {
	{375.84, 375.17, 372.99, 377.35},
	{353.91, 352.02, 351.18, 354.7},
	{331.38, 331.17, 328.81, 331.67},
	{295.83, 294.93, 294.65, 299.29}
};
const double drsp_4::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double drsp_4::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_q_rb_rise[4][4] = {
	{282.76, 288.46, 305.39, 452.47},
	{268.23, 273.11, 287.65, 421.97},
	{259.78, 263.65, 276.3, 398.1},
	{249.59, 250.94, 258, 348.36}
};
const double drsp_4::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double drsp_4::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double drsp_4::power_q_s_fall[4][4] = {
	{375.84, 375.17, 372.99, 377.35},
	{353.91, 352.02, 351.18, 354.7},
	{331.38, 331.17, 328.81, 331.67},
	{295.83, 294.93, 294.65, 299.29}
};
const double drsp_4::lin_q_s_fall[4] = {0, 20, 50, 250};
const double drsp_4::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double drsp_4::power_q_s_rise[4][4] = {
	{282.76, 288.46, 305.39, 452.47},
	{268.23, 273.11, 287.65, 421.97},
	{259.78, 263.65, 276.3, 398.1},
	{249.59, 250.94, 258, 348.36}
};
const double drsp_4::lin_q_s_rise[4] = {0, 20, 50, 250};
const double drsp_4::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: dtrsp_2
// PROCESS NAME: proc
void dtrsp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: dtrsp_2
// PROCESS NAME: ff_input
void dtrsp_2::ff_input()
{
	bool _next_ = ( ip.read() & ! sm.read() ) | ( sip.read() & sm.read() ) ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

dtrsp_2::~dtrsp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_sip = sip.get_interface();
	psc_objinfo_if *_p_sip = dynamic_cast<psc_objinfo_if*>(_if_sip);

	sc_interface *_if_sm = sm.get_interface();
	psc_objinfo_if *_p_sm = dynamic_cast<psc_objinfo_if*>(_if_sm);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_s_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_fall[j]) {
			pts_s_fall[0].x = col_s_fall[j-1];
			pts_s_fall[0].y = power_s_fall[j-1];

			pts_s_fall[1].x = col_s_fall[j];
			pts_s_fall[1].y = power_s_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_fall = psc_weighted_average(pts_s_fall, _p_s->get_net_delay());

	psc_point_t pts_s_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s->get_net_delay() < col_s_rise[j]) {
			pts_s_rise[0].x = col_s_rise[j-1];
			pts_s_rise[0].y = power_s_rise[j-1];

			pts_s_rise[1].x = col_s_rise[j];
			pts_s_rise[1].y = power_s_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_rise = psc_weighted_average(pts_s_rise, _p_s->get_net_delay());

	psc_point_t pts_sip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_sip->get_net_delay() < col_sip_fall[j]) {
			pts_sip_fall[0].x = col_sip_fall[j-1];
			pts_sip_fall[0].y = power_sip_fall[j-1];

			pts_sip_fall[1].x = col_sip_fall[j];
			pts_sip_fall[1].y = power_sip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_sip_fall = psc_weighted_average(pts_sip_fall, _p_sip->get_net_delay());

	psc_point_t pts_sip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_sip->get_net_delay() < col_sip_rise[j]) {
			pts_sip_rise[0].x = col_sip_rise[j-1];
			pts_sip_rise[0].y = power_sip_rise[j-1];

			pts_sip_rise[1].x = col_sip_rise[j];
			pts_sip_rise[1].y = power_sip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_sip_rise = psc_weighted_average(pts_sip_rise, _p_sip->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_s_fall(_p_s->get_id(), E_s_fall);
	pwr_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_fall);
	psc_pin_power_info pwr_s_rise(_p_s->get_id(), E_s_rise);
	pwr_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_s_rise);
	psc_pin_power_info pwr_sip_fall(_p_sip->get_id(), E_sip_fall);
	pwr_sip_fall.set_rel_pins(1, _p_sip->get_id().c_str());
	info.add(pwr_sip_fall);
	psc_pin_power_info pwr_sip_rise(_p_sip->get_id(), E_sip_rise);
	pwr_sip_rise.set_rel_pins(1, _p_sip->get_id().c_str());
	info.add(pwr_sip_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void dtrsp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_sip, delay_sip, wres_sip, wcap_sm, delay_sm, wres_sm, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_sip, *_if_sm, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_sip, *_p_sm, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_sip = sip.get_interface();
	_p_sip = dynamic_cast<psc_objinfo_if*>(_if_sip);
	wcap_sip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_sip->get_fanout()-1];
	_p_sip->set_wire_load(wcap_sip);
	wres_sip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_sip->get_fanout()-1] * 1e3;
	delay_sip = (wres_sip/(double)_p_sip->get_fanout())*((wcap_sip/(double)_p_sip->get_fanout()) + capacitance_sip);
	_p_sip->add_to_net_load(capacitance_sip);
	_p_sip->set_net_delay(delay_sip);

	_if_sm = sm.get_interface();
	_p_sm = dynamic_cast<psc_objinfo_if*>(_if_sm);
	wcap_sm = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_sm->get_fanout()-1];
	_p_sm->set_wire_load(wcap_sm);
	wres_sm = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_sm->get_fanout()-1] * 1e3;
	delay_sm = (wres_sm/(double)_p_sm->get_fanout())*((wcap_sm/(double)_p_sm->get_fanout()) + capacitance_sm);
	_p_sm->add_to_net_load(capacitance_sm);
	_p_sm->set_net_delay(delay_sm);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * dtrsp_2::celltype = "dtrsp_2";
const double dtrsp_2::leakage_power = 4.60455e-06;
const double dtrsp_2::capacitance_ck = 15.575;
const double dtrsp_2::fanout_load_ck = 3;
const double dtrsp_2::capacitance_ip = 5.101;
const double dtrsp_2::fanout_load_ip = 1;
const double dtrsp_2::capacitance_rb = 14.859;
const double dtrsp_2::fanout_load_rb = 3;
const double dtrsp_2::capacitance_s = 16.401;
const double dtrsp_2::fanout_load_s = 3;
const double dtrsp_2::capacitance_sip = 4.8963;
const double dtrsp_2::fanout_load_sip = 1;
const double dtrsp_2::capacitance_sm = 10.629;
const double dtrsp_2::fanout_load_sm = 2;
const double dtrsp_2::max_capacitance_q = 250;
const double dtrsp_2::max_fanout_q = 50;

const double dtrsp_2::power_ck_fall[4] = {
	187.48, 183.02, 190.15, 269.18
};
const double dtrsp_2::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_ck_rise[4] = {
	70.342, 66.696, 73.356, 163.64
};
const double dtrsp_2::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_ip_fall[4] = {
	238.1, 236.42, 241, 298.25
};
const double dtrsp_2::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_ip_rise[4] = {
	231.22, 231.54, 237.69, 309.11
};
const double dtrsp_2::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_rb_fall[4] = {
	85.565, 80.238, 80.139, 114.19
};
const double dtrsp_2::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_rb_rise[4] = {
	60.252, 57.975, 58.373, 75.057
};
const double dtrsp_2::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_s_fall[4] = {
	61.06, 60.039, 59.805, 68.696
};
const double dtrsp_2::col_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_s_rise[4] = {
	104.37, 96.229, 92.538, 97.675
};
const double dtrsp_2::col_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_sip_fall[4] = {
	235.65, 234.44, 239.18, 296.69
};
const double dtrsp_2::col_sip_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_sip_rise[4] = {
	228.83, 229.56, 235.85, 307.4
};
const double dtrsp_2::col_sip_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_q_ck_fall[4][4] = {
	{231.87, 230.66, 230.71, 235.84},
	{217.92, 216.85, 216.99, 222.9},
	{212.3, 211.13, 211.63, 216.98},
	{205.9, 204.67, 205.44, 211.15}
};
const double dtrsp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_q_ck_rise[4][4] = {
	{195.22, 199.44, 209.29, 294.75},
	{190.75, 193.75, 201.88, 277.63},
	{189.97, 192.2, 198.89, 268.02},
	{190.18, 191.62, 196.09, 250.25}
};
const double dtrsp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_q_rb_fall[4][4] = {
	{231.87, 230.66, 230.71, 235.84},
	{217.92, 216.85, 216.99, 222.9},
	{212.3, 211.13, 211.63, 216.98},
	{205.9, 204.67, 205.44, 211.15}
};
const double dtrsp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_q_rb_rise[4][4] = {
	{195.22, 199.44, 209.29, 294.75},
	{190.75, 193.75, 201.88, 277.63},
	{189.97, 192.2, 198.89, 268.02},
	{190.18, 191.62, 196.09, 250.25}
};
const double dtrsp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double dtrsp_2::power_q_s_fall[4][4] = {
	{231.87, 230.66, 230.71, 235.84},
	{217.92, 216.85, 216.99, 222.9},
	{212.3, 211.13, 211.63, 216.98},
	{205.9, 204.67, 205.44, 211.15}
};
const double dtrsp_2::lin_q_s_fall[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double dtrsp_2::power_q_s_rise[4][4] = {
	{195.22, 199.44, 209.29, 294.75},
	{190.75, 193.75, 201.88, 277.63},
	{189.97, 192.2, 198.89, 268.02},
	{190.18, 191.62, 196.09, 250.25}
};
const double dtrsp_2::lin_q_s_rise[4] = {0, 20, 50, 250};
const double dtrsp_2::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: inv_1
// PROCESS NAME: proc
void inv_1::proc()
{
	op.write(
		! ip.read() 
	);
}

inv_1::~inv_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void inv_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * inv_1::celltype = "inv_1";
const double inv_1::leakage_power = 2.01855e-08;
const double inv_1::capacitance_ip = 4.9075;
const double inv_1::fanout_load_ip = 1;
const double inv_1::max_capacitance_op = 250;
const double inv_1::max_fanout_op = 50;

const double inv_1::power_op_ip_fall[4][4] = {
	{24.932, 25.541, 38.222, 139.32},
	{25.58, 25.186, 32.031, 116.84},
	{25.533, 25.45, 29.901, 98.408},
	{25.032, 25.767, 27.166, 61.518}
};
const double inv_1::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double inv_1::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double inv_1::power_op_ip_rise[4][4] = {
	{23.398, 24.131, 34.406, 114.83},
	{24.764, 24.47, 29.834, 96.325},
	{24.528, 24.25, 27.727, 82.056},
	{24.043, 24.221, 25.272, 51.748}
};
const double inv_1::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double inv_1::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: inv_2
// PROCESS NAME: proc
void inv_2::proc()
{
	op.write(
		! ip.read() 
	);
}

inv_2::~inv_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void inv_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * inv_2::celltype = "inv_2";
const double inv_2::leakage_power = 2.3966e-08;
const double inv_2::capacitance_ip = 9.6963;
const double inv_2::fanout_load_ip = 2;
const double inv_2::max_capacitance_op = 250;
const double inv_2::max_fanout_op = 50;

const double inv_2::power_op_ip_fall[4][4] = {
	{46.041, 46.72, 71.797, 267.52},
	{46.886, 46.163, 61.752, 241.23},
	{47.512, 46.267, 58.02, 214.74},
	{46.761, 47.598, 52.243, 144.41}
};
const double inv_2::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double inv_2::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double inv_2::power_op_ip_rise[4][4] = {
	{42.684, 43.759, 63.849, 219.33},
	{45.547, 44.672, 57.992, 197.17},
	{45.759, 44.739, 53.919, 176.17},
	{44.68, 44.555, 47.843, 120.72}
};
const double inv_2::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double inv_2::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: inv_4
// PROCESS NAME: proc
void inv_4::proc()
{
	op.write(
		! ip.read() 
	);
}

inv_4::~inv_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void inv_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_ip, *_if_op;
	psc_objinfo_if *_p_ip, *_p_op;

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * inv_4::celltype = "inv_4";
const double inv_4::leakage_power = 4.7932e-08;
const double inv_4::capacitance_ip = 20.193;
const double inv_4::fanout_load_ip = 4;
const double inv_4::max_capacitance_op = 250;
const double inv_4::max_fanout_op = 50;

const double inv_4::power_op_ip_fall[4][4] = {
	{74.958, 75.92, 130.18, 527.27},
	{76.032, 73.663, 115, 495.28},
	{77.268, 74.051, 104.23, 459.54},
	{77.904, 77.106, 91.513, 335.98}
};
const double inv_4::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double inv_4::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double inv_4::power_op_ip_rise[4][4] = {
	{66.792, 69.595, 112.73, 429.53},
	{72.73, 70.312, 104.2, 402.28},
	{75.405, 72.221, 97.389, 372.55},
	{74.592, 72.614, 83.328, 276.89}
};
const double inv_4::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double inv_4::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: invzp_1
// PROCESS NAME: proc
void invzp_1::proc()
{
	op.write(
		! ip.read() 
	);
}

invzp_1::~invzp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_c = c.get_interface();
	psc_objinfo_if *_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_c_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_c->get_net_delay() < col_c_fall[j]) {
			pts_c_fall[0].x = col_c_fall[j-1];
			pts_c_fall[0].y = power_c_fall[j-1];

			pts_c_fall[1].x = col_c_fall[j];
			pts_c_fall[1].y = power_c_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_c_fall = psc_weighted_average(pts_c_fall, _p_c->get_net_delay());

	psc_point_t pts_c_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_c->get_net_delay() < col_c_rise[j]) {
			pts_c_rise[0].x = col_c_rise[j-1];
			pts_c_rise[0].y = power_c_rise[j-1];

			pts_c_rise[1].x = col_c_rise[j];
			pts_c_rise[1].y = power_c_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_c_rise = psc_weighted_average(pts_c_rise, _p_c->get_net_delay());

	psc_point_t pts_ip_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_fall[j]) {
			pts_ip_fall[0].x = col_ip_fall[j-1];
			pts_ip_fall[0].y = power_ip_fall[j-1];

			pts_ip_fall[1].x = col_ip_fall[j];
			pts_ip_fall[1].y = power_ip_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_fall = psc_weighted_average(pts_ip_fall, _p_ip->get_net_delay());

	psc_point_t pts_ip_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip->get_net_delay() < col_ip_rise[j]) {
			pts_ip_rise[0].x = col_ip_rise[j-1];
			pts_ip_rise[0].y = power_ip_rise[j-1];

			pts_ip_rise[1].x = col_ip_rise[j];
			pts_ip_rise[1].y = power_ip_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip_rise = psc_weighted_average(pts_ip_rise, _p_ip->get_net_delay());

	psc_point_t pts_op_c_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_fall[j]) {
					pts_op_c_fall[0].y = col_op_c_fall[j-1];
					pts_op_c_fall[0].x = lin_op_c_fall[i-1];
					pts_op_c_fall[0].z = power_op_c_fall[i-1][j-1];

					pts_op_c_fall[1].y = col_op_c_fall[j];
					pts_op_c_fall[1].x = lin_op_c_fall[i-1];
					pts_op_c_fall[1].z = power_op_c_fall[i-1][j];

					pts_op_c_fall[2].y = col_op_c_fall[j];
					pts_op_c_fall[2].x = lin_op_c_fall[i];
					pts_op_c_fall[2].z = power_op_c_fall[i][j];

					pts_op_c_fall[3].y = col_op_c_fall[j-1];
					pts_op_c_fall[3].x = lin_op_c_fall[i];
					pts_op_c_fall[3].z = power_op_c_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_fall = psc_geometric_centroid(pts_op_c_fall, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_c_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_rise[j]) {
					pts_op_c_rise[0].y = col_op_c_rise[j-1];
					pts_op_c_rise[0].x = lin_op_c_rise[i-1];
					pts_op_c_rise[0].z = power_op_c_rise[i-1][j-1];

					pts_op_c_rise[1].y = col_op_c_rise[j];
					pts_op_c_rise[1].x = lin_op_c_rise[i-1];
					pts_op_c_rise[1].z = power_op_c_rise[i-1][j];

					pts_op_c_rise[2].y = col_op_c_rise[j];
					pts_op_c_rise[2].x = lin_op_c_rise[i];
					pts_op_c_rise[2].z = power_op_c_rise[i][j];

					pts_op_c_rise[3].y = col_op_c_rise[j-1];
					pts_op_c_rise[3].x = lin_op_c_rise[i];
					pts_op_c_rise[3].z = power_op_c_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_rise = psc_geometric_centroid(pts_op_c_rise, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_c_fall(_p_c->get_id(), E_c_fall);
	pwr_c_fall.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_c_fall);
	psc_pin_power_info pwr_c_rise(_p_c->get_id(), E_c_rise);
	pwr_c_rise.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_c_rise);
	psc_pin_power_info pwr_ip_fall(_p_ip->get_id(), E_ip_fall);
	pwr_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_fall);
	psc_pin_power_info pwr_ip_rise(_p_ip->get_id(), E_ip_rise);
	pwr_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_ip_rise);
	psc_pin_power_info pwr_op_c_fall(_p_op->get_id(), E_op_c_fall);
	pwr_op_c_fall.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_fall);
	psc_pin_power_info pwr_op_c_rise(_p_op->get_id(), E_op_c_rise);
	pwr_op_c_rise.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_rise);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void invzp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_c, delay_c, wres_c, wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_c, *_if_ip, *_if_op;
	psc_objinfo_if *_p_c, *_p_ip, *_p_op;

	_if_c = c.get_interface();
	_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);
	wcap_c = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_c->get_fanout()-1];
	_p_c->set_wire_load(wcap_c);
	wres_c = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_c->get_fanout()-1] * 1e3;
	delay_c = (wres_c/(double)_p_c->get_fanout())*((wcap_c/(double)_p_c->get_fanout()) + capacitance_c);
	_p_c->add_to_net_load(capacitance_c);
	_p_c->set_net_delay(delay_c);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * invzp_1::celltype = "invzp_1";
const double invzp_1::leakage_power = 3.22585e-08;
const double invzp_1::capacitance_c = 5.1129;
const double invzp_1::fanout_load_c = 1;
const double invzp_1::capacitance_ip = 4.9927;
const double invzp_1::fanout_load_ip = 1;
const double invzp_1::max_capacitance_op = 250;
const double invzp_1::max_fanout_op = 50;

const double invzp_1::power_c_fall[4] = {
	26.438, 24.181, 31.497, 79.337
};
const double invzp_1::col_c_fall[4] = {0, 59.722, 125.27, 578.29};

const double invzp_1::power_c_rise[4] = {
	32.985, 32.233, 43.451, 142.75
};
const double invzp_1::col_c_rise[4] = {0, 66.037, 144.95, 672.54};

const double invzp_1::power_ip_fall[4] = {
	2.0867, 2.2177, 1.8675, 1.4335
};
const double invzp_1::col_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double invzp_1::power_ip_rise[4] = {
	1.5259, 1.4257, 1.1312, 0.90173
};
const double invzp_1::col_ip_rise[4] = {0, 66.037, 144.95, 672.54};

const double invzp_1::power_op_c_fall[4][4] = {
	{39.768, 39.524, 46.93, 130.66},
	{40.163, 39.981, 43.994, 110.5},
	{39.888, 40.151, 42.839, 94.912},
	{39.41, 39.856, 40.855, 65.063}
};
const double invzp_1::lin_op_c_fall[4] = {0, 20, 50, 250};
const double invzp_1::col_op_c_fall[4] = {0, 59.722, 125.27, 578.29};

const double invzp_1::power_op_c_rise[4][4] = {
	{35.377, 34.559, 39.236, 106.52},
	{35.537, 35.296, 37.392, 90},
	{35.578, 35.489, 36.687, 76.981},
	{35.635, 35.632, 35.985, 53.154}
};
const double invzp_1::lin_op_c_rise[4] = {0, 20, 50, 250};
const double invzp_1::col_op_c_rise[4] = {0, 66.037, 144.95, 672.54};

const double invzp_1::power_op_ip_fall[4][4] = {
	{39.768, 39.524, 46.93, 130.66},
	{40.163, 39.981, 43.994, 110.5},
	{39.888, 40.151, 42.839, 94.912},
	{39.41, 39.856, 40.855, 65.063}
};
const double invzp_1::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double invzp_1::col_op_ip_fall[4] = {0, 59.722, 125.27, 578.29};

const double invzp_1::power_op_ip_rise[4][4] = {
	{35.377, 34.559, 39.236, 106.52},
	{35.537, 35.296, 37.392, 90},
	{35.578, 35.489, 36.687, 76.981},
	{35.635, 35.632, 35.985, 53.154}
};
const double invzp_1::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double invzp_1::col_op_ip_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: invzp_2
// PROCESS NAME: proc
void invzp_2::proc()
{
	op.write(
		! ip.read() 
	);
}

invzp_2::~invzp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_c = c.get_interface();
	psc_objinfo_if *_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_c_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_fall[j]) {
					pts_op_c_fall[0].y = col_op_c_fall[j-1];
					pts_op_c_fall[0].x = lin_op_c_fall[i-1];
					pts_op_c_fall[0].z = power_op_c_fall[i-1][j-1];

					pts_op_c_fall[1].y = col_op_c_fall[j];
					pts_op_c_fall[1].x = lin_op_c_fall[i-1];
					pts_op_c_fall[1].z = power_op_c_fall[i-1][j];

					pts_op_c_fall[2].y = col_op_c_fall[j];
					pts_op_c_fall[2].x = lin_op_c_fall[i];
					pts_op_c_fall[2].z = power_op_c_fall[i][j];

					pts_op_c_fall[3].y = col_op_c_fall[j-1];
					pts_op_c_fall[3].x = lin_op_c_fall[i];
					pts_op_c_fall[3].z = power_op_c_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_fall = psc_geometric_centroid(pts_op_c_fall, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_c_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_rise[j]) {
					pts_op_c_rise[0].y = col_op_c_rise[j-1];
					pts_op_c_rise[0].x = lin_op_c_rise[i-1];
					pts_op_c_rise[0].z = power_op_c_rise[i-1][j-1];

					pts_op_c_rise[1].y = col_op_c_rise[j];
					pts_op_c_rise[1].x = lin_op_c_rise[i-1];
					pts_op_c_rise[1].z = power_op_c_rise[i-1][j];

					pts_op_c_rise[2].y = col_op_c_rise[j];
					pts_op_c_rise[2].x = lin_op_c_rise[i];
					pts_op_c_rise[2].z = power_op_c_rise[i][j];

					pts_op_c_rise[3].y = col_op_c_rise[j-1];
					pts_op_c_rise[3].x = lin_op_c_rise[i];
					pts_op_c_rise[3].z = power_op_c_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_rise = psc_geometric_centroid(pts_op_c_rise, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_c_fall(_p_op->get_id(), E_op_c_fall);
	pwr_op_c_fall.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_fall);
	psc_pin_power_info pwr_op_c_rise(_p_op->get_id(), E_op_c_rise);
	pwr_op_c_rise.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_rise);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void invzp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_c, delay_c, wres_c, wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_c, *_if_ip, *_if_op;
	psc_objinfo_if *_p_c, *_p_ip, *_p_op;

	_if_c = c.get_interface();
	_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);
	wcap_c = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_c->get_fanout()-1];
	_p_c->set_wire_load(wcap_c);
	wres_c = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_c->get_fanout()-1] * 1e3;
	delay_c = (wres_c/(double)_p_c->get_fanout())*((wcap_c/(double)_p_c->get_fanout()) + capacitance_c);
	_p_c->add_to_net_load(capacitance_c);
	_p_c->set_net_delay(delay_c);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * invzp_2::celltype = "invzp_2";
const double invzp_2::leakage_power = 3.90937e-08;
const double invzp_2::capacitance_c = 9.4231;
const double invzp_2::fanout_load_c = 2;
const double invzp_2::capacitance_ip = 9.2561;
const double invzp_2::fanout_load_ip = 2;
const double invzp_2::max_capacitance_op = 250;
const double invzp_2::max_fanout_op = 50;

const double invzp_2::power_op_c_fall[4][4] = {
	{74.046, 73.921, 88.539, 250.76},
	{74.45, 74.735, 84.348, 226.98},
	{74.812, 75.129, 82.126, 203.96},
	{74.264, 74.932, 77.928, 145.55}
};
const double invzp_2::lin_op_c_fall[4] = {0, 20, 50, 250};
const double invzp_2::col_op_c_fall[4] = {0, 66.037, 144.95, 672.54};

const double invzp_2::power_op_c_rise[4][4] = {
	{65.984, 63.811, 73.025, 203.11},
	{66.201, 65.285, 70.571, 183.98},
	{66.253, 65.826, 69.171, 164.66},
	{66.448, 66.334, 67.431, 117.13}
};
const double invzp_2::lin_op_c_rise[4] = {0, 20, 50, 250};
const double invzp_2::col_op_c_rise[4] = {0, 59.722, 125.27, 578.29};

const double invzp_2::power_op_ip_fall[4][4] = {
	{74.046, 73.921, 88.539, 250.76},
	{74.45, 74.735, 84.348, 226.98},
	{74.812, 75.129, 82.126, 203.96},
	{74.264, 74.932, 77.928, 145.55}
};
const double invzp_2::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double invzp_2::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double invzp_2::power_op_ip_rise[4][4] = {
	{65.984, 63.811, 73.025, 203.11},
	{66.201, 65.285, 70.571, 183.98},
	{66.253, 65.826, 69.171, 164.66},
	{66.448, 66.334, 67.431, 117.13}
};
const double invzp_2::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double invzp_2::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: invzp_4
// PROCESS NAME: proc
void invzp_4::proc()
{
	op.write(
		! ip.read() 
	);
}

invzp_4::~invzp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_c = c.get_interface();
	psc_objinfo_if *_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_c_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_fall[j]) {
					pts_op_c_fall[0].y = col_op_c_fall[j-1];
					pts_op_c_fall[0].x = lin_op_c_fall[i-1];
					pts_op_c_fall[0].z = power_op_c_fall[i-1][j-1];

					pts_op_c_fall[1].y = col_op_c_fall[j];
					pts_op_c_fall[1].x = lin_op_c_fall[i-1];
					pts_op_c_fall[1].z = power_op_c_fall[i-1][j];

					pts_op_c_fall[2].y = col_op_c_fall[j];
					pts_op_c_fall[2].x = lin_op_c_fall[i];
					pts_op_c_fall[2].z = power_op_c_fall[i][j];

					pts_op_c_fall[3].y = col_op_c_fall[j-1];
					pts_op_c_fall[3].x = lin_op_c_fall[i];
					pts_op_c_fall[3].z = power_op_c_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_fall = psc_geometric_centroid(pts_op_c_fall, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_c_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_c_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_c->get_net_delay() < col_op_c_rise[j]) {
					pts_op_c_rise[0].y = col_op_c_rise[j-1];
					pts_op_c_rise[0].x = lin_op_c_rise[i-1];
					pts_op_c_rise[0].z = power_op_c_rise[i-1][j-1];

					pts_op_c_rise[1].y = col_op_c_rise[j];
					pts_op_c_rise[1].x = lin_op_c_rise[i-1];
					pts_op_c_rise[1].z = power_op_c_rise[i-1][j];

					pts_op_c_rise[2].y = col_op_c_rise[j];
					pts_op_c_rise[2].x = lin_op_c_rise[i];
					pts_op_c_rise[2].z = power_op_c_rise[i][j];

					pts_op_c_rise[3].y = col_op_c_rise[j-1];
					pts_op_c_rise[3].x = lin_op_c_rise[i];
					pts_op_c_rise[3].z = power_op_c_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_c_rise = psc_geometric_centroid(pts_op_c_rise, _p_op->get_net_load(), _p_c->get_net_delay());

	psc_point_t pts_op_ip_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_fall[j]) {
					pts_op_ip_fall[0].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[0].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[0].z = power_op_ip_fall[i-1][j-1];

					pts_op_ip_fall[1].y = col_op_ip_fall[j];
					pts_op_ip_fall[1].x = lin_op_ip_fall[i-1];
					pts_op_ip_fall[1].z = power_op_ip_fall[i-1][j];

					pts_op_ip_fall[2].y = col_op_ip_fall[j];
					pts_op_ip_fall[2].x = lin_op_ip_fall[i];
					pts_op_ip_fall[2].z = power_op_ip_fall[i][j];

					pts_op_ip_fall[3].y = col_op_ip_fall[j-1];
					pts_op_ip_fall[3].x = lin_op_ip_fall[i];
					pts_op_ip_fall[3].z = power_op_ip_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_fall = psc_geometric_centroid(pts_op_ip_fall, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_point_t pts_op_ip_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip->get_net_delay() < col_op_ip_rise[j]) {
					pts_op_ip_rise[0].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[0].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[0].z = power_op_ip_rise[i-1][j-1];

					pts_op_ip_rise[1].y = col_op_ip_rise[j];
					pts_op_ip_rise[1].x = lin_op_ip_rise[i-1];
					pts_op_ip_rise[1].z = power_op_ip_rise[i-1][j];

					pts_op_ip_rise[2].y = col_op_ip_rise[j];
					pts_op_ip_rise[2].x = lin_op_ip_rise[i];
					pts_op_ip_rise[2].z = power_op_ip_rise[i][j];

					pts_op_ip_rise[3].y = col_op_ip_rise[j-1];
					pts_op_ip_rise[3].x = lin_op_ip_rise[i];
					pts_op_ip_rise[3].z = power_op_ip_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip_rise = psc_geometric_centroid(pts_op_ip_rise, _p_op->get_net_load(), _p_ip->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_c_fall(_p_op->get_id(), E_op_c_fall);
	pwr_op_c_fall.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_fall);
	psc_pin_power_info pwr_op_c_rise(_p_op->get_id(), E_op_c_rise);
	pwr_op_c_rise.set_rel_pins(1, _p_c->get_id().c_str());
	info.add(pwr_op_c_rise);
	psc_pin_power_info pwr_op_ip_fall(_p_op->get_id(), E_op_ip_fall);
	pwr_op_ip_fall.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_fall);
	psc_pin_power_info pwr_op_ip_rise(_p_op->get_id(), E_op_ip_rise);
	pwr_op_ip_rise.set_rel_pins(1, _p_ip->get_id().c_str());
	info.add(pwr_op_ip_rise);
	PSC_INSERT_CELL(info);
#endif
}

void invzp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_c, delay_c, wres_c, wcap_ip, delay_ip, wres_ip, wcap_op;
	sc_interface *_if_c, *_if_ip, *_if_op;
	psc_objinfo_if *_p_c, *_p_ip, *_p_op;

	_if_c = c.get_interface();
	_p_c = dynamic_cast<psc_objinfo_if*>(_if_c);
	wcap_c = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_c->get_fanout()-1];
	_p_c->set_wire_load(wcap_c);
	wres_c = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_c->get_fanout()-1] * 1e3;
	delay_c = (wres_c/(double)_p_c->get_fanout())*((wcap_c/(double)_p_c->get_fanout()) + capacitance_c);
	_p_c->add_to_net_load(capacitance_c);
	_p_c->set_net_delay(delay_c);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * invzp_4::celltype = "invzp_4";
const double invzp_4::leakage_power = 5.4219e-08;
const double invzp_4::capacitance_c = 12.179;
const double invzp_4::fanout_load_c = 2;
const double invzp_4::capacitance_ip = 19.373;
const double invzp_4::fanout_load_ip = 4;
const double invzp_4::max_capacitance_op = 250;
const double invzp_4::max_fanout_op = 50;

const double invzp_4::power_op_c_fall[4][4] = {
	{132.17, 131.41, 162.96, 492.81},
	{133.27, 132.12, 156.86, 464.78},
	{134.14, 134.38, 151.42, 432.58},
	{135.3, 136.18, 144.85, 328.66}
};
const double invzp_4::lin_op_c_fall[4] = {0, 20, 50, 250};
const double invzp_4::col_op_c_fall[4] = {0, 66.037, 144.95, 672.54};

const double invzp_4::power_op_c_rise[4][4] = {
	{115.43, 111.39, 130.98, 396.34},
	{116.75, 113.96, 128.05, 374.1},
	{117.71, 116.51, 125.65, 348.11},
	{119.24, 119.04, 122.25, 261.9}
};
const double invzp_4::lin_op_c_rise[4] = {0, 20, 50, 250};
const double invzp_4::col_op_c_rise[4] = {0, 59.722, 125.27, 578.29};

const double invzp_4::power_op_ip_fall[4][4] = {
	{132.17, 131.41, 162.96, 492.81},
	{133.27, 132.12, 156.86, 464.78},
	{134.14, 134.38, 151.42, 432.58},
	{135.3, 136.18, 144.85, 328.66}
};
const double invzp_4::lin_op_ip_fall[4] = {0, 20, 50, 250};
const double invzp_4::col_op_ip_fall[4] = {0, 66.037, 144.95, 672.54};

const double invzp_4::power_op_ip_rise[4][4] = {
	{115.43, 111.39, 130.98, 396.34},
	{116.75, 113.96, 128.05, 374.1},
	{117.71, 116.51, 125.65, 348.11},
	{119.24, 119.04, 122.25, 261.9}
};
const double invzp_4::lin_op_ip_rise[4] = {0, 20, 50, 250};
const double invzp_4::col_op_ip_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: lp_1
// PROCESS NAME: proc
void lp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lp_1
// PROCESS NAME: latch_input
void lp_1::latch_input()
{
	if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}
}

lp_1::~lp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lp_1::celltype = "lp_1";
const double lp_1::leakage_power = 1.67758e-06;
const double lp_1::capacitance_ck = 8.8743;
const double lp_1::fanout_load_ck = 2;
const double lp_1::capacitance_ip = 4.9216;
const double lp_1::fanout_load_ip = 1;
const double lp_1::max_capacitance_q = 250;
const double lp_1::max_fanout_q = 50;

const double lp_1::power_q_ck_fall[4][4] = {
	{165.69, 163.85, 164.36, 169.33},
	{153.88, 150.92, 152.49, 156.87},
	{148.22, 147.2, 147.63, 152.33},
	{144.77, 144.03, 144.68, 148.64}
};
const double lp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lp_1::power_q_ck_rise[4][4] = {
	{132.87, 136.8, 148.78, 244.22},
	{128.76, 131.25, 140.21, 227.19},
	{128.51, 129.84, 137, 218.37},
	{128.97, 129.56, 134.45, 202.7}
};
const double lp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lp_2
// PROCESS NAME: proc
void lp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lp_2
// PROCESS NAME: latch_input
void lp_2::latch_input()
{
	if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}
}

lp_2::~lp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lp_2::celltype = "lp_2";
const double lp_2::leakage_power = 3.36975e-06;
const double lp_2::capacitance_ck = 16.618;
const double lp_2::fanout_load_ck = 3;
const double lp_2::capacitance_ip = 9.3298;
const double lp_2::fanout_load_ip = 2;
const double lp_2::max_capacitance_q = 250;
const double lp_2::max_fanout_q = 50;

const double lp_2::power_q_ck_fall[4][4] = {
	{282.29, 279.4, 279.28, 289.51},
	{267.13, 267.42, 267.24, 274.64},
	{260.97, 256.01, 257.94, 267.4},
	{252.18, 251.39, 252.31, 259.78}
};
const double lp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lp_2::power_q_ck_rise[4][4] = {
	{228.96, 236.84, 260.7, 436.73},
	{224.12, 229.98, 250.29, 417.9},
	{223.24, 227.09, 243.97, 404.59},
	{223.7, 224.74, 235.89, 380.56}
};
const double lp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrp_1
// PROCESS NAME: proc
void lrp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrp_1
// PROCESS NAME: latch_input
void lrp_1::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}
}

lrp_1::~lrp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrp_1::celltype = "lrp_1";
const double lrp_1::leakage_power = 2.0165e-06;
const double lrp_1::capacitance_ck = 9.3625;
const double lrp_1::fanout_load_ck = 2;
const double lrp_1::capacitance_ip = 4.6556;
const double lrp_1::fanout_load_ip = 1;
const double lrp_1::capacitance_rb = 9.5738;
const double lrp_1::fanout_load_rb = 2;
const double lrp_1::max_capacitance_q = 250;
const double lrp_1::max_fanout_q = 50;

const double lrp_1::power_q_ck_fall[4][4] = {
	{142.41, 141.66, 141.34, 144.17},
	{139.14, 137.84, 137.88, 141.58},
	{138.3, 137.43, 137.13, 141.01},
	{137.1, 136.14, 136.2, 140.19}
};
const double lrp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_1::power_q_ck_rise[4][4] = {
	{123.97, 124.58, 131.11, 203.78},
	{121.7, 121.68, 127.15, 196.05},
	{121.25, 121.1, 125.83, 191.25},
	{120.9, 120.9, 125.06, 183.1}
};
const double lrp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrp_1::power_q_rb_fall[4][4] = {
	{142.41, 141.66, 141.34, 144.17},
	{139.14, 137.84, 137.88, 141.58},
	{138.3, 137.43, 137.13, 141.01},
	{137.1, 136.14, 136.2, 140.19}
};
const double lrp_1::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrp_1::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_1::power_q_rb_rise[4][4] = {
	{123.97, 124.58, 131.11, 203.78},
	{121.7, 121.68, 127.15, 196.05},
	{121.25, 121.1, 125.83, 191.25},
	{120.9, 120.9, 125.06, 183.1}
};
const double lrp_1::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrp_1::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrp_2
// PROCESS NAME: proc
void lrp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrp_2
// PROCESS NAME: latch_input
void lrp_2::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}
}

lrp_2::~lrp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrp_2::celltype = "lrp_2";
const double lrp_2::leakage_power = 2.26506e-06;
const double lrp_2::capacitance_ck = 9.2231;
const double lrp_2::fanout_load_ck = 2;
const double lrp_2::capacitance_ip = 4.6303;
const double lrp_2::fanout_load_ip = 1;
const double lrp_2::capacitance_rb = 9.4573;
const double lrp_2::fanout_load_rb = 2;
const double lrp_2::max_capacitance_q = 250;
const double lrp_2::max_fanout_q = 50;

const double lrp_2::power_q_ck_fall[4][4] = {
	{192.47, 190.86, 189.9, 189.93},
	{181.09, 179.19, 178.95, 180.86},
	{175.81, 174.51, 174.75, 176.38},
	{169.67, 168.45, 169.21, 171.68}
};
const double lrp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_2::power_q_ck_rise[4][4] = {
	{168.89, 170.61, 179.26, 272.2},
	{160.96, 162.14, 169.58, 255.25},
	{156.81, 157.67, 164.05, 244},
	{152.11, 152.4, 156.77, 221.16}
};
const double lrp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrp_2::power_q_rb_fall[4][4] = {
	{192.47, 190.86, 189.9, 189.93},
	{181.09, 179.19, 178.95, 180.86},
	{175.81, 174.51, 174.75, 176.38},
	{169.67, 168.45, 169.21, 171.68}
};
const double lrp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_2::power_q_rb_rise[4][4] = {
	{168.89, 170.61, 179.26, 272.2},
	{160.96, 162.14, 169.58, 255.25},
	{156.81, 157.67, 164.05, 244},
	{152.11, 152.4, 156.77, 221.16}
};
const double lrp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrp_4
// PROCESS NAME: proc
void lrp_4::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrp_4
// PROCESS NAME: latch_input
void lrp_4::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}
}

lrp_4::~lrp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrp_4::celltype = "lrp_4";
const double lrp_4::leakage_power = 3.05808e-06;
const double lrp_4::capacitance_ck = 11.536;
const double lrp_4::fanout_load_ck = 2;
const double lrp_4::capacitance_ip = 6.0133;
const double lrp_4::fanout_load_ip = 1;
const double lrp_4::capacitance_rb = 11.64;
const double lrp_4::fanout_load_rb = 2;
const double lrp_4::max_capacitance_q = 250;
const double lrp_4::max_fanout_q = 50;

const double lrp_4::power_q_ck_fall[4][4] = {
	{325.43, 324.72, 323.26, 318.87},
	{305.59, 301.32, 299.72, 298.72},
	{284.38, 284.41, 282.34, 279.07},
	{257.74, 256.1, 256.39, 257.09}
};
const double lrp_4::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrp_4::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_4::power_q_ck_rise[4][4] = {
	{288.93, 291.37, 307.01, 462.72},
	{267.82, 269.89, 284.08, 430.55},
	{252.83, 254.35, 268.04, 402.3},
	{232.35, 232.19, 240.43, 345.02}
};
const double lrp_4::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrp_4::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrp_4::power_q_rb_fall[4][4] = {
	{325.43, 324.72, 323.26, 318.87},
	{305.59, 301.32, 299.72, 298.72},
	{284.38, 284.41, 282.34, 279.07},
	{257.74, 256.1, 256.39, 257.09}
};
const double lrp_4::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrp_4::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrp_4::power_q_rb_rise[4][4] = {
	{288.93, 291.37, 307.01, 462.72},
	{267.82, 269.89, 284.08, 430.55},
	{252.83, 254.35, 268.04, 402.3},
	{232.35, 232.19, 240.43, 345.02}
};
const double lrp_4::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrp_4::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrsp_1
// PROCESS NAME: proc
void lrsp_1::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrsp_1
// PROCESS NAME: latch_input
void lrsp_1::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

lrsp_1::~lrsp_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrsp_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrsp_1::celltype = "lrsp_1";
const double lrsp_1::leakage_power = 2.64097e-06;
const double lrsp_1::capacitance_ck = 9.1513;
const double lrsp_1::fanout_load_ck = 2;
const double lrsp_1::capacitance_ip = 4.8103;
const double lrsp_1::fanout_load_ip = 1;
const double lrsp_1::capacitance_rb = 9.5125;
const double lrsp_1::fanout_load_rb = 2;
const double lrsp_1::capacitance_s = 9.9402;
const double lrsp_1::fanout_load_s = 2;
const double lrsp_1::max_capacitance_q = 250;
const double lrsp_1::max_fanout_q = 50;

const double lrsp_1::power_q_ck_fall[4][4] = {
	{161.77, 159.68, 158.5, 157.25},
	{153.41, 151.71, 151.61, 151},
	{149.58, 147.87, 148.14, 148.31},
	{144.12, 142.53, 143.25, 144.66}
};
const double lrsp_1::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_1::power_q_ck_rise[4][4] = {
	{139.55, 140.08, 145.61, 210.17},
	{135.61, 135.96, 140.58, 201.71},
	{133.89, 134.24, 138.3, 195.59},
	{131.69, 132.28, 135.7, 184.29}
};
const double lrsp_1::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_1::power_q_rb_fall[4][4] = {
	{161.77, 159.68, 158.5, 157.25},
	{153.41, 151.71, 151.61, 151},
	{149.58, 147.87, 148.14, 148.31},
	{144.12, 142.53, 143.25, 144.66}
};
const double lrsp_1::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_1::power_q_rb_rise[4][4] = {
	{139.55, 140.08, 145.61, 210.17},
	{135.61, 135.96, 140.58, 201.71},
	{133.89, 134.24, 138.3, 195.59},
	{131.69, 132.28, 135.7, 184.29}
};
const double lrsp_1::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_1::power_q_s_fall[4][4] = {
	{161.77, 159.68, 158.5, 157.25},
	{153.41, 151.71, 151.61, 151},
	{149.58, 147.87, 148.14, 148.31},
	{144.12, 142.53, 143.25, 144.66}
};
const double lrsp_1::lin_q_s_fall[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_1::power_q_s_rise[4][4] = {
	{139.55, 140.08, 145.61, 210.17},
	{135.61, 135.96, 140.58, 201.71},
	{133.89, 134.24, 138.3, 195.59},
	{131.69, 132.28, 135.7, 184.29}
};
const double lrsp_1::lin_q_s_rise[4] = {0, 20, 50, 250};
const double lrsp_1::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrsp_2
// PROCESS NAME: proc
void lrsp_2::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrsp_2
// PROCESS NAME: latch_input
void lrsp_2::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

lrsp_2::~lrsp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrsp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrsp_2::celltype = "lrsp_2";
const double lrsp_2::leakage_power = 2.70883e-06;
const double lrsp_2::capacitance_ck = 9.2564;
const double lrsp_2::fanout_load_ck = 2;
const double lrsp_2::capacitance_ip = 4.7526;
const double lrsp_2::fanout_load_ip = 1;
const double lrsp_2::capacitance_rb = 9.5128;
const double lrsp_2::fanout_load_rb = 2;
const double lrsp_2::capacitance_s = 10.113;
const double lrsp_2::fanout_load_s = 2;
const double lrsp_2::max_capacitance_q = 250;
const double lrsp_2::max_fanout_q = 50;

const double lrsp_2::power_q_ck_fall[4][4] = {
	{237.29, 235.19, 232.96, 226.85},
	{220.73, 218.51, 217.51, 211.23},
	{208.36, 206.43, 205.71, 201.42},
	{189.81, 188.04, 187.72, 187.43}
};
const double lrsp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_2::power_q_ck_rise[4][4] = {
	{192.65, 193.68, 201.11, 283.53},
	{182.77, 183.89, 190.46, 266.66},
	{177.47, 178.25, 183.97, 254.99},
	{169.91, 170.47, 174.39, 229.48}
};
const double lrsp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_2::power_q_rb_fall[4][4] = {
	{237.29, 235.19, 232.96, 226.85},
	{220.73, 218.51, 217.51, 211.23},
	{208.36, 206.43, 205.71, 201.42},
	{189.81, 188.04, 187.72, 187.43}
};
const double lrsp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_2::power_q_rb_rise[4][4] = {
	{192.65, 193.68, 201.11, 283.53},
	{182.77, 183.89, 190.46, 266.66},
	{177.47, 178.25, 183.97, 254.99},
	{169.91, 170.47, 174.39, 229.48}
};
const double lrsp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_2::power_q_s_fall[4][4] = {
	{237.29, 235.19, 232.96, 226.85},
	{220.73, 218.51, 217.51, 211.23},
	{208.36, 206.43, 205.71, 201.42},
	{189.81, 188.04, 187.72, 187.43}
};
const double lrsp_2::lin_q_s_fall[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_2::power_q_s_rise[4][4] = {
	{192.65, 193.68, 201.11, 283.53},
	{182.77, 183.89, 190.46, 266.66},
	{177.47, 178.25, 183.97, 254.99},
	{169.91, 170.47, 174.39, 229.48}
};
const double lrsp_2::lin_q_s_rise[4] = {0, 20, 50, 250};
const double lrsp_2::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: lrsp_4
// PROCESS NAME: proc
void lrsp_4::proc()
{
	q.write(
		IQ.read() 
	);
}

// MODULE: lrsp_4
// PROCESS NAME: latch_input
void lrsp_4::latch_input()
{
	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
	else if ( s.read() == 1 ) {
		IQ.write(1);
		IQN.write(0);
	}
	else if ( ck.read() == 1 ) {
		bool _next_ = ck.read();
		IQ.write(_next_);
		IQN.write(!_next_);
	}

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQ.write(0);

	if ( (rb.read() == 0) && (s.read() == 1) )
		IQN.write(0);
}

lrsp_4::~lrsp_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_ip = ip.get_interface();
	psc_objinfo_if *_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	int i, j;
	bool p_set;

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_fall[j]) {
					pts_q_s_fall[0].y = col_q_s_fall[j-1];
					pts_q_s_fall[0].x = lin_q_s_fall[i-1];
					pts_q_s_fall[0].z = power_q_s_fall[i-1][j-1];

					pts_q_s_fall[1].y = col_q_s_fall[j];
					pts_q_s_fall[1].x = lin_q_s_fall[i-1];
					pts_q_s_fall[1].z = power_q_s_fall[i-1][j];

					pts_q_s_fall[2].y = col_q_s_fall[j];
					pts_q_s_fall[2].x = lin_q_s_fall[i];
					pts_q_s_fall[2].z = power_q_s_fall[i][j];

					pts_q_s_fall[3].y = col_q_s_fall[j-1];
					pts_q_s_fall[3].x = lin_q_s_fall[i];
					pts_q_s_fall[3].z = power_q_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_fall = psc_geometric_centroid(pts_q_s_fall, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_q_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_q_s_rise[j]) {
					pts_q_s_rise[0].y = col_q_s_rise[j-1];
					pts_q_s_rise[0].x = lin_q_s_rise[i-1];
					pts_q_s_rise[0].z = power_q_s_rise[i-1][j-1];

					pts_q_s_rise[1].y = col_q_s_rise[j];
					pts_q_s_rise[1].x = lin_q_s_rise[i-1];
					pts_q_s_rise[1].z = power_q_s_rise[i-1][j];

					pts_q_s_rise[2].y = col_q_s_rise[j];
					pts_q_s_rise[2].x = lin_q_s_rise[i];
					pts_q_s_rise[2].z = power_q_s_rise[i][j];

					pts_q_s_rise[3].y = col_q_s_rise[j-1];
					pts_q_s_rise[3].x = lin_q_s_rise[i];
					pts_q_s_rise[3].z = power_q_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_s_rise = psc_geometric_centroid(pts_q_s_rise, _p_q->get_net_load(), _p_s->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	psc_pin_power_info pwr_q_s_fall(_p_q->get_id(), E_q_s_fall);
	pwr_q_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_fall);
	psc_pin_power_info pwr_q_s_rise(_p_q->get_id(), E_q_s_rise);
	pwr_q_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_q_s_rise);
	PSC_INSERT_CELL(info);
#endif
}

void lrsp_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_ip, delay_ip, wres_ip, wcap_rb, delay_rb, wres_rb, wcap_s, delay_s, wres_s, wcap_q;
	sc_interface *_if_ck, *_if_ip, *_if_rb, *_if_s, *_if_q;
	psc_objinfo_if *_p_ck, *_p_ip, *_p_rb, *_p_s, *_p_q;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_ip = ip.get_interface();
	_p_ip = dynamic_cast<psc_objinfo_if*>(_if_ip);
	wcap_ip = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1];
	_p_ip->set_wire_load(wcap_ip);
	wres_ip = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip->get_fanout()-1] * 1e3;
	delay_ip = (wres_ip/(double)_p_ip->get_fanout())*((wcap_ip/(double)_p_ip->get_fanout()) + capacitance_ip);
	_p_ip->add_to_net_load(capacitance_ip);
	_p_ip->set_net_delay(delay_ip);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);
#endif
}
const char * lrsp_4::celltype = "lrsp_4";
const double lrsp_4::leakage_power = 3.31428e-06;
const double lrsp_4::capacitance_ck = 11.475;
const double lrsp_4::fanout_load_ck = 2;
const double lrsp_4::capacitance_ip = 6.0184;
const double lrsp_4::fanout_load_ip = 1;
const double lrsp_4::capacitance_rb = 11.668;
const double lrsp_4::fanout_load_rb = 2;
const double lrsp_4::capacitance_s = 12.22;
const double lrsp_4::fanout_load_s = 2;
const double lrsp_4::max_capacitance_q = 250;
const double lrsp_4::max_fanout_q = 50;

const double lrsp_4::power_q_ck_fall[4][4] = {
	{423.08, 421.47, 418.73, 404.43},
	{397.9, 394.52, 391.7, 376.95},
	{369.82, 367.77, 365.87, 351.97},
	{308, 305.56, 304.27, 297.57}
};
const double lrsp_4::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_4::power_q_ck_rise[4][4] = {
	{324.79, 322.67, 336.05, 474.26},
	{302.96, 300.43, 313.27, 442.6},
	{286.05, 284.12, 295.66, 414.73},
	{260, 256.78, 264.28, 356.64}
};
const double lrsp_4::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_4::power_q_rb_fall[4][4] = {
	{423.08, 421.47, 418.73, 404.43},
	{397.9, 394.52, 391.7, 376.95},
	{369.82, 367.77, 365.87, 351.97},
	{308, 305.56, 304.27, 297.57}
};
const double lrsp_4::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_4::power_q_rb_rise[4][4] = {
	{324.79, 322.67, 336.05, 474.26},
	{302.96, 300.43, 313.27, 442.6},
	{286.05, 284.12, 295.66, 414.73},
	{260, 256.78, 264.28, 356.64}
};
const double lrsp_4::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double lrsp_4::power_q_s_fall[4][4] = {
	{423.08, 421.47, 418.73, 404.43},
	{397.9, 394.52, 391.7, 376.95},
	{369.82, 367.77, 365.87, 351.97},
	{308, 305.56, 304.27, 297.57}
};
const double lrsp_4::lin_q_s_fall[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double lrsp_4::power_q_s_rise[4][4] = {
	{324.79, 322.67, 336.05, 474.26},
	{302.96, 300.43, 313.27, 442.6},
	{286.05, 284.12, 295.66, 414.73},
	{260, 256.78, 264.28, 356.64}
};
const double lrsp_4::lin_q_s_rise[4] = {0, 20, 50, 250};
const double lrsp_4::col_q_s_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: mux2_1
// PROCESS NAME: proc
void mux2_1::proc()
{
	op.write(
		( ( ! s.read() & ip1.read() ) | ( s.read() & ip2.read() ) ) 
	);
}

mux2_1::~mux2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_fall[j]) {
					pts_op_s_fall[0].y = col_op_s_fall[j-1];
					pts_op_s_fall[0].x = lin_op_s_fall[i-1];
					pts_op_s_fall[0].z = power_op_s_fall[i-1][j-1];

					pts_op_s_fall[1].y = col_op_s_fall[j];
					pts_op_s_fall[1].x = lin_op_s_fall[i-1];
					pts_op_s_fall[1].z = power_op_s_fall[i-1][j];

					pts_op_s_fall[2].y = col_op_s_fall[j];
					pts_op_s_fall[2].x = lin_op_s_fall[i];
					pts_op_s_fall[2].z = power_op_s_fall[i][j];

					pts_op_s_fall[3].y = col_op_s_fall[j-1];
					pts_op_s_fall[3].x = lin_op_s_fall[i];
					pts_op_s_fall[3].z = power_op_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_fall = psc_geometric_centroid(pts_op_s_fall, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_rise[j]) {
					pts_op_s_rise[0].y = col_op_s_rise[j-1];
					pts_op_s_rise[0].x = lin_op_s_rise[i-1];
					pts_op_s_rise[0].z = power_op_s_rise[i-1][j-1];

					pts_op_s_rise[1].y = col_op_s_rise[j];
					pts_op_s_rise[1].x = lin_op_s_rise[i-1];
					pts_op_s_rise[1].z = power_op_s_rise[i-1][j];

					pts_op_s_rise[2].y = col_op_s_rise[j];
					pts_op_s_rise[2].x = lin_op_s_rise[i];
					pts_op_s_rise[2].z = power_op_s_rise[i][j];

					pts_op_s_rise[3].y = col_op_s_rise[j-1];
					pts_op_s_rise[3].x = lin_op_s_rise[i];
					pts_op_s_rise[3].z = power_op_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_rise = psc_geometric_centroid(pts_op_s_rise, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_s_fall(_p_op->get_id(), E_op_s_fall);
	pwr_op_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_fall);
	psc_pin_power_info pwr_op_s_rise(_p_op->get_id(), E_op_s_rise);
	pwr_op_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_rise);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void mux2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_s, delay_s, wres_s, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_s, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_s, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * mux2_1::celltype = "mux2_1";
const double mux2_1::leakage_power = 6.68043e-08;
const double mux2_1::capacitance_ip1 = 6.2218;
const double mux2_1::fanout_load_ip1 = 1;
const double mux2_1::capacitance_ip2 = 5.1606;
const double mux2_1::fanout_load_ip2 = 1;
const double mux2_1::capacitance_s = 10.75;
const double mux2_1::fanout_load_s = 2;
const double mux2_1::max_capacitance_op = 250;
const double mux2_1::max_fanout_op = 50;

const double mux2_1::power_op_s_fall[4][4] = {
	{124.34, 120.46, 125.74, 183.23},
	{121.12, 117.11, 122.2, 179.27},
	{121.39, 117.39, 122.63, 179.12},
	{121.36, 117.32, 122.57, 179}
};
const double mux2_1::lin_op_s_fall[4] = {0, 20, 50, 250};
const double mux2_1::col_op_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_1::power_op_s_rise[4][4] = {
	{118.3, 114.93, 127.61, 276},
	{118.4, 114.45, 125.77, 266.88},
	{118.93, 114.86, 125.39, 262.74},
	{119.75, 115.74, 126.06, 258.37}
};
const double mux2_1::lin_op_s_rise[4] = {0, 20, 50, 250};
const double mux2_1::col_op_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_1::power_op_ip1_fall[4][4] = {
	{124.34, 120.46, 125.74, 183.23},
	{121.12, 117.11, 122.2, 179.27},
	{121.39, 117.39, 122.63, 179.12},
	{121.36, 117.32, 122.57, 179}
};
const double mux2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double mux2_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_1::power_op_ip1_rise[4][4] = {
	{118.3, 114.93, 127.61, 276},
	{118.4, 114.45, 125.77, 266.88},
	{118.93, 114.86, 125.39, 262.74},
	{119.75, 115.74, 126.06, 258.37}
};
const double mux2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double mux2_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_1::power_op_ip2_fall[4][4] = {
	{124.34, 120.46, 125.74, 183.23},
	{121.12, 117.11, 122.2, 179.27},
	{121.39, 117.39, 122.63, 179.12},
	{121.36, 117.32, 122.57, 179}
};
const double mux2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double mux2_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_1::power_op_ip2_rise[4][4] = {
	{118.3, 114.93, 127.61, 276},
	{118.4, 114.45, 125.77, 266.88},
	{118.93, 114.86, 125.39, 262.74},
	{119.75, 115.74, 126.06, 258.37}
};
const double mux2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double mux2_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: mux2_2
// PROCESS NAME: proc
void mux2_2::proc()
{
	op.write(
		( ( ! s.read() & ip1.read() ) | ( s.read() & ip2.read() ) ) 
	);
}

mux2_2::~mux2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_fall[j]) {
					pts_op_s_fall[0].y = col_op_s_fall[j-1];
					pts_op_s_fall[0].x = lin_op_s_fall[i-1];
					pts_op_s_fall[0].z = power_op_s_fall[i-1][j-1];

					pts_op_s_fall[1].y = col_op_s_fall[j];
					pts_op_s_fall[1].x = lin_op_s_fall[i-1];
					pts_op_s_fall[1].z = power_op_s_fall[i-1][j];

					pts_op_s_fall[2].y = col_op_s_fall[j];
					pts_op_s_fall[2].x = lin_op_s_fall[i];
					pts_op_s_fall[2].z = power_op_s_fall[i][j];

					pts_op_s_fall[3].y = col_op_s_fall[j-1];
					pts_op_s_fall[3].x = lin_op_s_fall[i];
					pts_op_s_fall[3].z = power_op_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_fall = psc_geometric_centroid(pts_op_s_fall, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_rise[j]) {
					pts_op_s_rise[0].y = col_op_s_rise[j-1];
					pts_op_s_rise[0].x = lin_op_s_rise[i-1];
					pts_op_s_rise[0].z = power_op_s_rise[i-1][j-1];

					pts_op_s_rise[1].y = col_op_s_rise[j];
					pts_op_s_rise[1].x = lin_op_s_rise[i-1];
					pts_op_s_rise[1].z = power_op_s_rise[i-1][j];

					pts_op_s_rise[2].y = col_op_s_rise[j];
					pts_op_s_rise[2].x = lin_op_s_rise[i];
					pts_op_s_rise[2].z = power_op_s_rise[i][j];

					pts_op_s_rise[3].y = col_op_s_rise[j-1];
					pts_op_s_rise[3].x = lin_op_s_rise[i];
					pts_op_s_rise[3].z = power_op_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_rise = psc_geometric_centroid(pts_op_s_rise, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_s_fall(_p_op->get_id(), E_op_s_fall);
	pwr_op_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_fall);
	psc_pin_power_info pwr_op_s_rise(_p_op->get_id(), E_op_s_rise);
	pwr_op_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_rise);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void mux2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_s, delay_s, wres_s, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_s, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_s, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * mux2_2::celltype = "mux2_2";
const double mux2_2::leakage_power = 6.99627e-08;
const double mux2_2::capacitance_ip1 = 6.268;
const double mux2_2::fanout_load_ip1 = 1;
const double mux2_2::capacitance_ip2 = 5.1026;
const double mux2_2::fanout_load_ip2 = 1;
const double mux2_2::capacitance_s = 11.143;
const double mux2_2::fanout_load_s = 2;
const double mux2_2::max_capacitance_op = 250;
const double mux2_2::max_fanout_op = 50;

const double mux2_2::power_op_s_fall[4][4] = {
	{173.88, 170.03, 174.89, 232.32},
	{162.3, 157.41, 162.27, 219.8},
	{158.38, 154.58, 159.82, 216.02},
	{155.78, 151.56, 156.58, 212.48}
};
const double mux2_2::lin_op_s_fall[4] = {0, 20, 50, 250};
const double mux2_2::col_op_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_2::power_op_s_rise[4][4] = {
	{156.27, 153.41, 167.41, 332.37},
	{152.18, 148.59, 160.89, 316.45},
	{150.95, 147.09, 158.46, 307.05},
	{150.5, 146.12, 156.04, 291.36}
};
const double mux2_2::lin_op_s_rise[4] = {0, 20, 50, 250};
const double mux2_2::col_op_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_2::power_op_ip1_fall[4][4] = {
	{173.88, 170.03, 174.89, 232.32},
	{162.3, 157.41, 162.27, 219.8},
	{158.38, 154.58, 159.82, 216.02},
	{155.78, 151.56, 156.58, 212.48}
};
const double mux2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double mux2_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_2::power_op_ip1_rise[4][4] = {
	{156.27, 153.41, 167.41, 332.37},
	{152.18, 148.59, 160.89, 316.45},
	{150.95, 147.09, 158.46, 307.05},
	{150.5, 146.12, 156.04, 291.36}
};
const double mux2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double mux2_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_2::power_op_ip2_fall[4][4] = {
	{173.88, 170.03, 174.89, 232.32},
	{162.3, 157.41, 162.27, 219.8},
	{158.38, 154.58, 159.82, 216.02},
	{155.78, 151.56, 156.58, 212.48}
};
const double mux2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double mux2_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_2::power_op_ip2_rise[4][4] = {
	{156.27, 153.41, 167.41, 332.37},
	{152.18, 148.59, 160.89, 316.45},
	{150.95, 147.09, 158.46, 307.05},
	{150.5, 146.12, 156.04, 291.36}
};
const double mux2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double mux2_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: mux2_4
// PROCESS NAME: proc
void mux2_4::proc()
{
	op.write(
		( ( ! s.read() & ip1.read() ) | ( s.read() & ip2.read() ) ) 
	);
}

mux2_4::~mux2_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_s_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_fall[j]) {
					pts_op_s_fall[0].y = col_op_s_fall[j-1];
					pts_op_s_fall[0].x = lin_op_s_fall[i-1];
					pts_op_s_fall[0].z = power_op_s_fall[i-1][j-1];

					pts_op_s_fall[1].y = col_op_s_fall[j];
					pts_op_s_fall[1].x = lin_op_s_fall[i-1];
					pts_op_s_fall[1].z = power_op_s_fall[i-1][j];

					pts_op_s_fall[2].y = col_op_s_fall[j];
					pts_op_s_fall[2].x = lin_op_s_fall[i];
					pts_op_s_fall[2].z = power_op_s_fall[i][j];

					pts_op_s_fall[3].y = col_op_s_fall[j-1];
					pts_op_s_fall[3].x = lin_op_s_fall[i];
					pts_op_s_fall[3].z = power_op_s_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_fall = psc_geometric_centroid(pts_op_s_fall, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_s_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s->get_net_delay() < col_op_s_rise[j]) {
					pts_op_s_rise[0].y = col_op_s_rise[j-1];
					pts_op_s_rise[0].x = lin_op_s_rise[i-1];
					pts_op_s_rise[0].z = power_op_s_rise[i-1][j-1];

					pts_op_s_rise[1].y = col_op_s_rise[j];
					pts_op_s_rise[1].x = lin_op_s_rise[i-1];
					pts_op_s_rise[1].z = power_op_s_rise[i-1][j];

					pts_op_s_rise[2].y = col_op_s_rise[j];
					pts_op_s_rise[2].x = lin_op_s_rise[i];
					pts_op_s_rise[2].z = power_op_s_rise[i][j];

					pts_op_s_rise[3].y = col_op_s_rise[j-1];
					pts_op_s_rise[3].x = lin_op_s_rise[i];
					pts_op_s_rise[3].z = power_op_s_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s_rise = psc_geometric_centroid(pts_op_s_rise, _p_op->get_net_load(), _p_s->get_net_delay());

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_s_fall(_p_op->get_id(), E_op_s_fall);
	pwr_op_s_fall.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_fall);
	psc_pin_power_info pwr_op_s_rise(_p_op->get_id(), E_op_s_rise);
	pwr_op_s_rise.set_rel_pins(1, _p_s->get_id().c_str());
	info.add(pwr_op_s_rise);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void mux2_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_s, delay_s, wres_s, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_s, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_s, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);
	wres_s = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s->get_fanout()-1] * 1e3;
	delay_s = (wres_s/(double)_p_s->get_fanout())*((wcap_s/(double)_p_s->get_fanout()) + capacitance_s);
	_p_s->add_to_net_load(capacitance_s);
	_p_s->set_net_delay(delay_s);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * mux2_4::celltype = "mux2_4";
const double mux2_4::leakage_power = 9.5307e-08;
const double mux2_4::capacitance_ip1 = 6.103;
const double mux2_4::fanout_load_ip1 = 1;
const double mux2_4::capacitance_ip2 = 4.972;
const double mux2_4::fanout_load_ip2 = 1;
const double mux2_4::capacitance_s = 10.708;
const double mux2_4::fanout_load_s = 2;
const double mux2_4::max_capacitance_op = 250;
const double mux2_4::max_fanout_op = 50;

const double mux2_4::power_op_s_fall[4][4] = {
	{314.64, 311.26, 315.72, 372.74},
	{285.64, 283.3, 287.35, 344.19},
	{261.97, 258.2, 263.63, 318.9},
	{227.52, 224.02, 228.92, 283.39}
};
const double mux2_4::lin_op_s_fall[4] = {0, 20, 50, 250};
const double mux2_4::col_op_s_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_4::power_op_s_rise[4][4] = {
	{250.3, 248.92, 266.36, 469.51},
	{229.65, 227.85, 244.33, 437.84},
	{218.06, 215.88, 230.39, 411.59},
	{204.3, 200.83, 211.96, 363.93}
};
const double mux2_4::lin_op_s_rise[4] = {0, 20, 50, 250};
const double mux2_4::col_op_s_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_4::power_op_ip1_fall[4][4] = {
	{314.64, 311.26, 315.72, 372.74},
	{285.64, 283.3, 287.35, 344.19},
	{261.97, 258.2, 263.63, 318.9},
	{227.52, 224.02, 228.92, 283.39}
};
const double mux2_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double mux2_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_4::power_op_ip1_rise[4][4] = {
	{250.3, 248.92, 266.36, 469.51},
	{229.65, 227.85, 244.33, 437.84},
	{218.06, 215.88, 230.39, 411.59},
	{204.3, 200.83, 211.96, 363.93}
};
const double mux2_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double mux2_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux2_4::power_op_ip2_fall[4][4] = {
	{314.64, 311.26, 315.72, 372.74},
	{285.64, 283.3, 287.35, 344.19},
	{261.97, 258.2, 263.63, 318.9},
	{227.52, 224.02, 228.92, 283.39}
};
const double mux2_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double mux2_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double mux2_4::power_op_ip2_rise[4][4] = {
	{250.3, 248.92, 266.36, 469.51},
	{229.65, 227.85, 244.33, 437.84},
	{218.06, 215.88, 230.39, 411.59},
	{204.3, 200.83, 211.96, 363.93}
};
const double mux2_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double mux2_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: nand2_1
// PROCESS NAME: proc
void nand2_1::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() ) 
	);
}

nand2_1::~nand2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand2_1::celltype = "nand2_1";
const double nand2_1::leakage_power = 1.93973e-08;
const double nand2_1::capacitance_ip1 = 4.9414;
const double nand2_1::fanout_load_ip1 = 1;
const double nand2_1::capacitance_ip2 = 5.1895;
const double nand2_1::fanout_load_ip2 = 1;
const double nand2_1::max_capacitance_op = 250;
const double nand2_1::max_fanout_op = 50;

const double nand2_1::power_op_ip1_fall[4][4] = {
	{31.043, 28.931, 38.626, 129.64},
	{31.35, 29.692, 34.795, 109.07},
	{31.318, 30.291, 33.487, 92.551},
	{30.952, 30.534, 31.538, 60.28}
};
const double nand2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand2_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_1::power_op_ip1_rise[4][4] = {
	{31.823, 30.678, 38.523, 109.57},
	{32.6, 31.747, 35.681, 92.563},
	{32.235, 31.703, 34.146, 78.983},
	{31.706, 31.675, 32.412, 52.873}
};
const double nand2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand2_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand2_1::power_op_ip2_fall[4][4] = {
	{31.043, 28.931, 38.626, 129.64},
	{31.35, 29.692, 34.795, 109.07},
	{31.318, 30.291, 33.487, 92.551},
	{30.952, 30.534, 31.538, 60.28}
};
const double nand2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand2_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_1::power_op_ip2_rise[4][4] = {
	{31.823, 30.678, 38.523, 109.57},
	{32.6, 31.747, 35.681, 92.563},
	{32.235, 31.703, 34.146, 78.983},
	{31.706, 31.675, 32.412, 52.873}
};
const double nand2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand2_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand2_2
// PROCESS NAME: proc
void nand2_2::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() ) 
	);
}

nand2_2::~nand2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand2_2::celltype = "nand2_2";
const double nand2_2::leakage_power = 2.31628e-08;
const double nand2_2::capacitance_ip1 = 9.4414;
const double nand2_2::fanout_load_ip1 = 2;
const double nand2_2::capacitance_ip2 = 9.9725;
const double nand2_2::fanout_load_ip2 = 2;
const double nand2_2::max_capacitance_op = 250;
const double nand2_2::max_fanout_op = 50;

const double nand2_2::power_op_ip1_fall[4][4] = {
	{56.563, 52.286, 71.637, 248.38},
	{57.195, 53.021, 65.516, 224.1},
	{57.392, 54.422, 63.012, 199.83},
	{56.825, 55.503, 58.837, 137.45}
};
const double nand2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand2_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_2::power_op_ip1_rise[4][4] = {
	{58.025, 55.478, 71.567, 208.79},
	{59.874, 57.615, 66.955, 188.87},
	{59.654, 57.977, 64.426, 168.89},
	{58.414, 57.921, 60.298, 118.01}
};
const double nand2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand2_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand2_2::power_op_ip2_fall[4][4] = {
	{56.563, 52.286, 71.637, 248.38},
	{57.195, 53.021, 65.516, 224.1},
	{57.392, 54.422, 63.012, 199.83},
	{56.825, 55.503, 58.837, 137.45}
};
const double nand2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand2_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_2::power_op_ip2_rise[4][4] = {
	{58.025, 55.478, 71.567, 208.79},
	{59.874, 57.615, 66.955, 188.87},
	{59.654, 57.977, 64.426, 168.89},
	{58.414, 57.921, 60.298, 118.01}
};
const double nand2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand2_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand2_4
// PROCESS NAME: proc
void nand2_4::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() ) 
	);
}

nand2_4::~nand2_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand2_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand2_4::celltype = "nand2_4";
const double nand2_4::leakage_power = 4.63255e-08;
const double nand2_4::capacitance_ip1 = 19.829;
const double nand2_4::fanout_load_ip1 = 4;
const double nand2_4::capacitance_ip2 = 20.332;
const double nand2_4::fanout_load_ip2 = 4;
const double nand2_4::max_capacitance_op = 250;
const double nand2_4::max_fanout_op = 50;

const double nand2_4::power_op_ip1_fall[4][4] = {
	{106.9, 98, 138.42, 493.11},
	{107.86, 98.463, 129.45, 465.72},
	{108.51, 100.12, 123.73, 433.75},
	{108.42, 104.49, 114.89, 324.79}
};
const double nand2_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand2_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_4::power_op_ip1_rise[4][4] = {
	{108.69, 103.27, 136.34, 413.16},
	{111.13, 105.06, 130.06, 390.7},
	{112.85, 108.39, 125.44, 364.26},
	{110.9, 108.75, 116.38, 274.64}
};
const double nand2_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand2_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand2_4::power_op_ip2_fall[4][4] = {
	{106.9, 98, 138.42, 493.11},
	{107.86, 98.463, 129.45, 465.72},
	{108.51, 100.12, 123.73, 433.75},
	{108.42, 104.49, 114.89, 324.79}
};
const double nand2_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand2_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand2_4::power_op_ip2_rise[4][4] = {
	{108.69, 103.27, 136.34, 413.16},
	{111.13, 105.06, 130.06, 390.7},
	{112.85, 108.39, 125.44, 364.26},
	{110.9, 108.75, 116.38, 274.64}
};
const double nand2_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand2_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand3_1
// PROCESS NAME: proc
void nand3_1::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

nand3_1::~nand3_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand3_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand3_1::celltype = "nand3_1";
const double nand3_1::leakage_power = 1.50461e-08;
const double nand3_1::capacitance_ip1 = 4.8745;
const double nand3_1::fanout_load_ip1 = 1;
const double nand3_1::capacitance_ip2 = 5.1519;
const double nand3_1::fanout_load_ip2 = 1;
const double nand3_1::capacitance_ip3 = 6.29;
const double nand3_1::fanout_load_ip3 = 1;
const double nand3_1::max_capacitance_op = 250;
const double nand3_1::max_fanout_op = 50;

const double nand3_1::power_op_ip1_fall[4][4] = {
	{44.722, 40.891, 47.45, 127.5},
	{44.803, 42.379, 45.798, 110.35},
	{44.643, 43.005, 45.146, 96.436},
	{44.428, 43.65, 44.191, 68.746}
};
const double nand3_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_1::power_op_ip1_rise[4][4] = {
	{46.597, 44.585, 49.879, 110.96},
	{46.869, 45.827, 48.39, 96.191},
	{46.486, 45.837, 47.513, 84.518},
	{45.952, 45.762, 46.334, 62.863}
};
const double nand3_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_1::power_op_ip2_fall[4][4] = {
	{44.722, 40.891, 47.45, 127.5},
	{44.803, 42.379, 45.798, 110.35},
	{44.643, 43.005, 45.146, 96.436},
	{44.428, 43.65, 44.191, 68.746}
};
const double nand3_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_1::power_op_ip2_rise[4][4] = {
	{46.597, 44.585, 49.879, 110.96},
	{46.869, 45.827, 48.39, 96.191},
	{46.486, 45.837, 47.513, 84.518},
	{45.952, 45.762, 46.334, 62.863}
};
const double nand3_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_1::power_op_ip3_fall[4][4] = {
	{44.722, 40.891, 47.45, 127.5},
	{44.803, 42.379, 45.798, 110.35},
	{44.643, 43.005, 45.146, 96.436},
	{44.428, 43.65, 44.191, 68.746}
};
const double nand3_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_1::power_op_ip3_rise[4][4] = {
	{46.597, 44.585, 49.879, 110.96},
	{46.869, 45.827, 48.39, 96.191},
	{46.486, 45.837, 47.513, 84.518},
	{45.952, 45.762, 46.334, 62.863}
};
const double nand3_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand3_1::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand3_2
// PROCESS NAME: proc
void nand3_2::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

nand3_2::~nand3_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand3_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand3_2::celltype = "nand3_2";
const double nand3_2::leakage_power = 1.78765e-08;
const double nand3_2::capacitance_ip1 = 9.8842;
const double nand3_2::fanout_load_ip1 = 2;
const double nand3_2::capacitance_ip2 = 10.257;
const double nand3_2::fanout_load_ip2 = 2;
const double nand3_2::capacitance_ip3 = 10.4;
const double nand3_2::fanout_load_ip3 = 2;
const double nand3_2::max_capacitance_op = 250;
const double nand3_2::max_fanout_op = 50;

const double nand3_2::power_op_ip1_fall[4][4] = {
	{79.09, 71.749, 85.249, 242.25},
	{79.37, 73.563, 82.364, 221.74},
	{79.4, 75.005, 81.207, 200.96},
	{78.831, 76.721, 78.832, 147.2}
};
const double nand3_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_2::power_op_ip1_rise[4][4] = {
	{82.94, 79.043, 90.044, 209.67},
	{83.806, 81.307, 87.546, 192.13},
	{83.519, 81.75, 86.315, 174.4},
	{82.252, 81.559, 83.31, 130.68}
};
const double nand3_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_2::power_op_ip2_fall[4][4] = {
	{79.09, 71.749, 85.249, 242.25},
	{79.37, 73.563, 82.364, 221.74},
	{79.4, 75.005, 81.207, 200.96},
	{78.831, 76.721, 78.832, 147.2}
};
const double nand3_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_2::power_op_ip2_rise[4][4] = {
	{82.94, 79.043, 90.044, 209.67},
	{83.806, 81.307, 87.546, 192.13},
	{83.519, 81.75, 86.315, 174.4},
	{82.252, 81.559, 83.31, 130.68}
};
const double nand3_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_2::power_op_ip3_fall[4][4] = {
	{79.09, 71.749, 85.249, 242.25},
	{79.37, 73.563, 82.364, 221.74},
	{79.4, 75.005, 81.207, 200.96},
	{78.831, 76.721, 78.832, 147.2}
};
const double nand3_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_2::power_op_ip3_rise[4][4] = {
	{82.94, 79.043, 90.044, 209.67},
	{83.806, 81.307, 87.546, 192.13},
	{83.519, 81.75, 86.315, 174.4},
	{82.252, 81.559, 83.31, 130.68}
};
const double nand3_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand3_2::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand3_4
// PROCESS NAME: proc
void nand3_4::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() ) 
	);
}

nand3_4::~nand3_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand3_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand3_4::celltype = "nand3_4";
const double nand3_4::leakage_power = 2.92216e-08;
const double nand3_4::capacitance_ip1 = 19.344;
const double nand3_4::fanout_load_ip1 = 4;
const double nand3_4::capacitance_ip2 = 20.023;
const double nand3_4::fanout_load_ip2 = 4;
const double nand3_4::capacitance_ip3 = 19.765;
const double nand3_4::fanout_load_ip3 = 4;
const double nand3_4::max_capacitance_op = 250;
const double nand3_4::max_fanout_op = 50;

const double nand3_4::power_op_ip1_fall[4][4] = {
	{98.718, 89.028, 108.21, 319.75},
	{99.326, 90.975, 103.87, 296.59},
	{99.413, 92.528, 101.74, 272.08},
	{98.729, 94.62, 98.661, 202.86}
};
const double nand3_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_4::power_op_ip1_rise[4][4] = {
	{111.9, 105.27, 121.39, 291.1},
	{113.42, 106.62, 118.16, 273.71},
	{113.45, 107.88, 115.73, 254.26},
	{112.41, 109.47, 112.05, 195.03}
};
const double nand3_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_4::power_op_ip2_fall[4][4] = {
	{98.718, 89.028, 108.21, 319.75},
	{99.326, 90.975, 103.87, 296.59},
	{99.413, 92.528, 101.74, 272.08},
	{98.729, 94.62, 98.661, 202.86}
};
const double nand3_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_4::power_op_ip2_rise[4][4] = {
	{111.9, 105.27, 121.39, 291.1},
	{113.42, 106.62, 118.16, 273.71},
	{113.45, 107.88, 115.73, 254.26},
	{112.41, 109.47, 112.05, 195.03}
};
const double nand3_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand3_4::power_op_ip3_fall[4][4] = {
	{98.718, 89.028, 108.21, 319.75},
	{99.326, 90.975, 103.87, 296.59},
	{99.413, 92.528, 101.74, 272.08},
	{98.729, 94.62, 98.661, 202.86}
};
const double nand3_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand3_4::power_op_ip3_rise[4][4] = {
	{111.9, 105.27, 121.39, 291.1},
	{113.42, 106.62, 118.16, 273.71},
	{113.45, 107.88, 115.73, 254.26},
	{112.41, 109.47, 112.05, 195.03}
};
const double nand3_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand3_4::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand4_1
// PROCESS NAME: proc
void nand4_1::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

nand4_1::~nand4_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand4_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand4_1::celltype = "nand4_1";
const double nand4_1::leakage_power = 1.08761e-08;
const double nand4_1::capacitance_ip1 = 4.9167;
const double nand4_1::fanout_load_ip1 = 1;
const double nand4_1::capacitance_ip2 = 5.1866;
const double nand4_1::fanout_load_ip2 = 1;
const double nand4_1::capacitance_ip3 = 5.8159;
const double nand4_1::fanout_load_ip3 = 1;
const double nand4_1::capacitance_ip4 = 6.054;
const double nand4_1::fanout_load_ip4 = 1;
const double nand4_1::max_capacitance_op = 250;
const double nand4_1::max_fanout_op = 50;

const double nand4_1::power_op_ip1_fall[4][4] = {
	{51.188, 46.863, 51.443, 123.74},
	{51.192, 48.389, 50.741, 108.44},
	{51.036, 49.088, 50.446, 96.115},
	{50.889, 49.914, 50.174, 71.513}
};
const double nand4_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_1::power_op_ip1_rise[4][4] = {
	{55.017, 53.336, 56.943, 110.33},
	{55.221, 54.138, 56.049, 97.137},
	{54.881, 54.158, 55.412, 86.955},
	{54.339, 54.107, 54.548, 68.471}
};
const double nand4_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_1::power_op_ip2_fall[4][4] = {
	{51.188, 46.863, 51.443, 123.74},
	{51.192, 48.389, 50.741, 108.44},
	{51.036, 49.088, 50.446, 96.115},
	{50.889, 49.914, 50.174, 71.513}
};
const double nand4_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_1::power_op_ip2_rise[4][4] = {
	{55.017, 53.336, 56.943, 110.33},
	{55.221, 54.138, 56.049, 97.137},
	{54.881, 54.158, 55.412, 86.955},
	{54.339, 54.107, 54.548, 68.471}
};
const double nand4_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_1::power_op_ip3_fall[4][4] = {
	{51.188, 46.863, 51.443, 123.74},
	{51.192, 48.389, 50.741, 108.44},
	{51.036, 49.088, 50.446, 96.115},
	{50.889, 49.914, 50.174, 71.513}
};
const double nand4_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_1::power_op_ip3_rise[4][4] = {
	{55.017, 53.336, 56.943, 110.33},
	{55.221, 54.138, 56.049, 97.137},
	{54.881, 54.158, 55.412, 86.955},
	{54.339, 54.107, 54.548, 68.471}
};
const double nand4_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_1::power_op_ip4_fall[4][4] = {
	{51.188, 46.863, 51.443, 123.74},
	{51.192, 48.389, 50.741, 108.44},
	{51.036, 49.088, 50.446, 96.115},
	{50.889, 49.914, 50.174, 71.513}
};
const double nand4_1::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_1::power_op_ip4_rise[4][4] = {
	{55.017, 53.336, 56.943, 110.33},
	{55.221, 54.138, 56.049, 97.137},
	{54.881, 54.158, 55.412, 86.955},
	{54.339, 54.107, 54.548, 68.471}
};
const double nand4_1::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nand4_1::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand4_2
// PROCESS NAME: proc
void nand4_2::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

nand4_2::~nand4_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand4_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand4_2::celltype = "nand4_2";
const double nand4_2::leakage_power = 1.27627e-08;
const double nand4_2::capacitance_ip1 = 9.7668;
const double nand4_2::fanout_load_ip1 = 2;
const double nand4_2::capacitance_ip2 = 10.154;
const double nand4_2::fanout_load_ip2 = 2;
const double nand4_2::capacitance_ip3 = 10.729;
const double nand4_2::fanout_load_ip3 = 2;
const double nand4_2::capacitance_ip4 = 11.059;
const double nand4_2::fanout_load_ip4 = 2;
const double nand4_2::max_capacitance_op = 250;
const double nand4_2::max_fanout_op = 50;

const double nand4_2::power_op_ip1_fall[4][4] = {
	{90.598, 82.04, 91.882, 234.28},
	{90.735, 84.1, 90.523, 215.83},
	{90.617, 85.625, 89.852, 197.24},
	{90.221, 87.716, 88.9, 149.28}
};
const double nand4_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_2::power_op_ip1_rise[4][4] = {
	{97.99, 94.166, 102.44, 207.8},
	{98.63, 96.129, 100.93, 191.8},
	{98.509, 96.694, 100.06, 176.02},
	{97.271, 96.3, 97.8, 138}
};
const double nand4_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_2::power_op_ip2_fall[4][4] = {
	{90.598, 82.04, 91.882, 234.28},
	{90.735, 84.1, 90.523, 215.83},
	{90.617, 85.625, 89.852, 197.24},
	{90.221, 87.716, 88.9, 149.28}
};
const double nand4_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_2::power_op_ip2_rise[4][4] = {
	{97.99, 94.166, 102.44, 207.8},
	{98.63, 96.129, 100.93, 191.8},
	{98.509, 96.694, 100.06, 176.02},
	{97.271, 96.3, 97.8, 138}
};
const double nand4_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_2::power_op_ip3_fall[4][4] = {
	{90.598, 82.04, 91.882, 234.28},
	{90.735, 84.1, 90.523, 215.83},
	{90.617, 85.625, 89.852, 197.24},
	{90.221, 87.716, 88.9, 149.28}
};
const double nand4_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_2::power_op_ip3_rise[4][4] = {
	{97.99, 94.166, 102.44, 207.8},
	{98.63, 96.129, 100.93, 191.8},
	{98.509, 96.694, 100.06, 176.02},
	{97.271, 96.3, 97.8, 138}
};
const double nand4_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_2::power_op_ip4_fall[4][4] = {
	{90.598, 82.04, 91.882, 234.28},
	{90.735, 84.1, 90.523, 215.83},
	{90.617, 85.625, 89.852, 197.24},
	{90.221, 87.716, 88.9, 149.28}
};
const double nand4_2::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_2::power_op_ip4_rise[4][4] = {
	{97.99, 94.166, 102.44, 207.8},
	{98.63, 96.129, 100.93, 191.8},
	{98.509, 96.694, 100.06, 176.02},
	{97.271, 96.3, 97.8, 138}
};
const double nand4_2::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nand4_2::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nand4_4
// PROCESS NAME: proc
void nand4_4::proc()
{
	op.write(
		! ( ip1.read() & ip2.read() & ip3.read() & ip4.read() ) 
	);
}

nand4_4::~nand4_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nand4_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nand4_4::celltype = "nand4_4";
const double nand4_4::leakage_power = 9.03834e-08;
const double nand4_4::capacitance_ip1 = 10.972;
const double nand4_4::fanout_load_ip1 = 2;
const double nand4_4::capacitance_ip2 = 10.629;
const double nand4_4::fanout_load_ip2 = 2;
const double nand4_4::capacitance_ip3 = 10.595;
const double nand4_4::fanout_load_ip3 = 2;
const double nand4_4::capacitance_ip4 = 9.8668;
const double nand4_4::fanout_load_ip4 = 2;
const double nand4_4::max_capacitance_op = 250;
const double nand4_4::max_fanout_op = 50;

const double nand4_4::power_op_ip1_fall[4][4] = {
	{324.09, 317.51, 328.86, 493.43},
	{316.3, 309.44, 320.67, 482.87},
	{314.75, 308.12, 318.57, 479.25},
	{318.52, 311.34, 322.1, 479.56}
};
const double nand4_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_4::power_op_ip1_rise[4][4] = {
	{306.95, 304.43, 313.41, 442.72},
	{306.7, 304.08, 312.7, 439.91},
	{308.76, 305.53, 314.28, 439.23},
	{311.53, 308.42, 316.09, 436.85}
};
const double nand4_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_4::power_op_ip2_fall[4][4] = {
	{324.09, 317.51, 328.86, 493.43},
	{316.3, 309.44, 320.67, 482.87},
	{314.75, 308.12, 318.57, 479.25},
	{318.52, 311.34, 322.1, 479.56}
};
const double nand4_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_4::power_op_ip2_rise[4][4] = {
	{306.95, 304.43, 313.41, 442.72},
	{306.7, 304.08, 312.7, 439.91},
	{308.76, 305.53, 314.28, 439.23},
	{311.53, 308.42, 316.09, 436.85}
};
const double nand4_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_4::power_op_ip3_fall[4][4] = {
	{324.09, 317.51, 328.86, 493.43},
	{316.3, 309.44, 320.67, 482.87},
	{314.75, 308.12, 318.57, 479.25},
	{318.52, 311.34, 322.1, 479.56}
};
const double nand4_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_4::power_op_ip3_rise[4][4] = {
	{306.95, 304.43, 313.41, 442.72},
	{306.7, 304.08, 312.7, 439.91},
	{308.76, 305.53, 314.28, 439.23},
	{311.53, 308.42, 316.09, 436.85}
};
const double nand4_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nand4_4::power_op_ip4_fall[4][4] = {
	{324.09, 317.51, 328.86, 493.43},
	{316.3, 309.44, 320.67, 482.87},
	{314.75, 308.12, 318.57, 479.25},
	{318.52, 311.34, 322.1, 479.56}
};
const double nand4_4::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nand4_4::power_op_ip4_rise[4][4] = {
	{306.95, 304.43, 313.41, 442.72},
	{306.7, 304.08, 312.7, 439.91},
	{308.76, 305.53, 314.28, 439.23},
	{311.53, 308.42, 316.09, 436.85}
};
const double nand4_4::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nand4_4::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor2_1
// PROCESS NAME: proc
void nor2_1::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() ) 
	);
}

nor2_1::~nor2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor2_1::celltype = "nor2_1";
const double nor2_1::leakage_power = 2.02626e-08;
const double nor2_1::capacitance_ip1 = 5.7129;
const double nor2_1::fanout_load_ip1 = 1;
const double nor2_1::capacitance_ip2 = 5.6805;
const double nor2_1::fanout_load_ip2 = 1;
const double nor2_1::max_capacitance_op = 250;
const double nor2_1::max_fanout_op = 50;

const double nor2_1::power_op_ip1_fall[4][4] = {
	{41.682, 38.659, 45.811, 125.54},
	{41.8, 39.734, 43.631, 107.73},
	{41.885, 40.587, 42.998, 93.775},
	{41.287, 41.059, 41.833, 66.585}
};
const double nor2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor2_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_1::power_op_ip1_rise[4][4] = {
	{35.984, 31.595, 37.281, 101.8},
	{36.462, 32.872, 35.48, 87.595},
	{36.4, 33.715, 34.944, 76.717},
	{36.273, 34.959, 35.016, 53.578}
};
const double nor2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor2_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor2_1::power_op_ip2_fall[4][4] = {
	{41.682, 38.659, 45.811, 125.54},
	{41.8, 39.734, 43.631, 107.73},
	{41.885, 40.587, 42.998, 93.775},
	{41.287, 41.059, 41.833, 66.585}
};
const double nor2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor2_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_1::power_op_ip2_rise[4][4] = {
	{35.984, 31.595, 37.281, 101.8},
	{36.462, 32.872, 35.48, 87.595},
	{36.4, 33.715, 34.944, 76.717},
	{36.273, 34.959, 35.016, 53.578}
};
const double nor2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor2_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor2_2
// PROCESS NAME: proc
void nor2_2::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() ) 
	);
}

nor2_2::~nor2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor2_2::celltype = "nor2_2";
const double nor2_2::leakage_power = 2.3646e-08;
const double nor2_2::capacitance_ip1 = 10.37;
const double nor2_2::fanout_load_ip1 = 2;
const double nor2_2::capacitance_ip2 = 10.323;
const double nor2_2::fanout_load_ip2 = 2;
const double nor2_2::max_capacitance_op = 250;
const double nor2_2::max_fanout_op = 50;

const double nor2_2::power_op_ip1_fall[4][4] = {
	{71.566, 66.974, 82.428, 238.4},
	{71.825, 67.767, 78.116, 216.84},
	{72.374, 68.954, 76.28, 195.73},
	{71.818, 70.968, 73.65, 141.86}
};
const double nor2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor2_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_2::power_op_ip1_rise[4][4] = {
	{60.621, 53.324, 65.265, 191.37},
	{61.835, 54.801, 62.045, 173.43},
	{61.792, 55.704, 60.409, 157.13},
	{61.506, 58.349, 59.057, 113.42}
};
const double nor2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor2_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor2_2::power_op_ip2_fall[4][4] = {
	{71.566, 66.974, 82.428, 238.4},
	{71.825, 67.767, 78.116, 216.84},
	{72.374, 68.954, 76.28, 195.73},
	{71.818, 70.968, 73.65, 141.86}
};
const double nor2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor2_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_2::power_op_ip2_rise[4][4] = {
	{60.621, 53.324, 65.265, 191.37},
	{61.835, 54.801, 62.045, 173.43},
	{61.792, 55.704, 60.409, 157.13},
	{61.506, 58.349, 59.057, 113.42}
};
const double nor2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor2_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor2_4
// PROCESS NAME: proc
void nor2_4::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() ) 
	);
}

nor2_4::~nor2_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor2_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor2_4::celltype = "nor2_4";
const double nor2_4::leakage_power = 4.72907e-08;
const double nor2_4::capacitance_ip1 = 19.938;
const double nor2_4::fanout_load_ip1 = 4;
const double nor2_4::capacitance_ip2 = 19.328;
const double nor2_4::fanout_load_ip2 = 4;
const double nor2_4::max_capacitance_op = 250;
const double nor2_4::max_fanout_op = 50;

const double nor2_4::power_op_ip1_fall[4][4] = {
	{133.53, 126.57, 159.48, 473.64},
	{133.34, 127.57, 152.09, 449.22},
	{133.98, 127.75, 147.88, 420.84},
	{135.17, 130.9, 141.33, 325.77}
};
const double nor2_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor2_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_4::power_op_ip1_rise[4][4] = {
	{111.35, 99.848, 124.83, 379.27},
	{113.56, 100.88, 120.31, 358.05},
	{113.93, 102.25, 116.46, 335.43},
	{113.57, 105.73, 110.42, 261.19}
};
const double nor2_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor2_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor2_4::power_op_ip2_fall[4][4] = {
	{133.53, 126.57, 159.48, 473.64},
	{133.34, 127.57, 152.09, 449.22},
	{133.98, 127.75, 147.88, 420.84},
	{135.17, 130.9, 141.33, 325.77}
};
const double nor2_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor2_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor2_4::power_op_ip2_rise[4][4] = {
	{111.35, 99.848, 124.83, 379.27},
	{113.56, 100.88, 120.31, 358.05},
	{113.93, 102.25, 116.46, 335.43},
	{113.57, 105.73, 110.42, 261.19}
};
const double nor2_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor2_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor3_1
// PROCESS NAME: proc
void nor3_1::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

nor3_1::~nor3_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor3_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor3_1::celltype = "nor3_1";
const double nor3_1::leakage_power = 1.58319e-08;
const double nor3_1::capacitance_ip1 = 4.8484;
const double nor3_1::fanout_load_ip1 = 1;
const double nor3_1::capacitance_ip2 = 5.632;
const double nor3_1::fanout_load_ip2 = 1;
const double nor3_1::capacitance_ip3 = 5.7983;
const double nor3_1::fanout_load_ip3 = 1;
const double nor3_1::max_capacitance_op = 250;
const double nor3_1::max_fanout_op = 50;

const double nor3_1::power_op_ip1_fall[4][4] = {
	{51.246, 48.911, 53.627, 118.49},
	{51.567, 49.674, 52.472, 104.02},
	{51.647, 50.364, 52.117, 92.866},
	{50.81, 50.28, 51.051, 70.884}
};
const double nor3_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_1::power_op_ip1_rise[4][4] = {
	{42.651, 38.111, 41.017, 93.925},
	{42.898, 39.394, 40.347, 82.667},
	{42.898, 40.202, 40.353, 73.722},
	{42.871, 41.427, 41.069, 54.97}
};
const double nor3_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_1::power_op_ip2_fall[4][4] = {
	{51.246, 48.911, 53.627, 118.49},
	{51.567, 49.674, 52.472, 104.02},
	{51.647, 50.364, 52.117, 92.866},
	{50.81, 50.28, 51.051, 70.884}
};
const double nor3_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_1::power_op_ip2_rise[4][4] = {
	{42.651, 38.111, 41.017, 93.925},
	{42.898, 39.394, 40.347, 82.667},
	{42.898, 40.202, 40.353, 73.722},
	{42.871, 41.427, 41.069, 54.97}
};
const double nor3_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_1::power_op_ip3_fall[4][4] = {
	{51.246, 48.911, 53.627, 118.49},
	{51.567, 49.674, 52.472, 104.02},
	{51.647, 50.364, 52.117, 92.866},
	{50.81, 50.28, 51.051, 70.884}
};
const double nor3_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_1::power_op_ip3_rise[4][4] = {
	{42.651, 38.111, 41.017, 93.925},
	{42.898, 39.394, 40.347, 82.667},
	{42.898, 40.202, 40.353, 73.722},
	{42.871, 41.427, 41.069, 54.97}
};
const double nor3_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor3_1::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor3_2
// PROCESS NAME: proc
void nor3_2::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

nor3_2::~nor3_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor3_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor3_2::celltype = "nor3_2";
const double nor3_2::leakage_power = 1.82882e-08;
const double nor3_2::capacitance_ip1 = 9.6105;
const double nor3_2::fanout_load_ip1 = 2;
const double nor3_2::capacitance_ip2 = 10.105;
const double nor3_2::fanout_load_ip2 = 2;
const double nor3_2::capacitance_ip3 = 10.183;
const double nor3_2::fanout_load_ip3 = 2;
const double nor3_2::max_capacitance_op = 250;
const double nor3_2::max_fanout_op = 50;

const double nor3_2::power_op_ip1_fall[4][4] = {
	{89.505, 85.575, 95.766, 223.39},
	{89.906, 86.158, 93.028, 205.52},
	{90.432, 87.054, 92.383, 188.46},
	{89.985, 88.533, 90.472, 145.22}
};
const double nor3_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_2::power_op_ip1_rise[4][4] = {
	{72.321, 64.178, 70.375, 174.35},
	{72.926, 65.561, 69.138, 160.08},
	{73.068, 66.864, 68.499, 146.91},
	{73.04, 69.53, 69.002, 110.92}
};
const double nor3_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_2::power_op_ip2_fall[4][4] = {
	{89.505, 85.575, 95.766, 223.39},
	{89.906, 86.158, 93.028, 205.52},
	{90.432, 87.054, 92.383, 188.46},
	{89.985, 88.533, 90.472, 145.22}
};
const double nor3_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_2::power_op_ip2_rise[4][4] = {
	{72.321, 64.178, 70.375, 174.35},
	{72.926, 65.561, 69.138, 160.08},
	{73.068, 66.864, 68.499, 146.91},
	{73.04, 69.53, 69.002, 110.92}
};
const double nor3_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_2::power_op_ip3_fall[4][4] = {
	{89.505, 85.575, 95.766, 223.39},
	{89.906, 86.158, 93.028, 205.52},
	{90.432, 87.054, 92.383, 188.46},
	{89.985, 88.533, 90.472, 145.22}
};
const double nor3_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_2::power_op_ip3_rise[4][4] = {
	{72.321, 64.178, 70.375, 174.35},
	{72.926, 65.561, 69.138, 160.08},
	{73.068, 66.864, 68.499, 146.91},
	{73.04, 69.53, 69.002, 110.92}
};
const double nor3_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor3_2::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor3_4
// PROCESS NAME: proc
void nor3_4::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

nor3_4::~nor3_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor3_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor3_4::celltype = "nor3_4";
const double nor3_4::leakage_power = 3.65766e-08;
const double nor3_4::capacitance_ip1 = 19.973;
const double nor3_4::fanout_load_ip1 = 4;
const double nor3_4::capacitance_ip2 = 19.004;
const double nor3_4::fanout_load_ip2 = 4;
const double nor3_4::capacitance_ip3 = 19.557;
const double nor3_4::fanout_load_ip3 = 4;
const double nor3_4::max_capacitance_op = 250;
const double nor3_4::max_fanout_op = 50;

const double nor3_4::power_op_ip1_fall[4][4] = {
	{160.65, 152.2, 175.43, 436.19},
	{160.34, 153.34, 170.52, 414.66},
	{160.98, 154.19, 167.9, 390.49},
	{162.24, 157.99, 164.4, 312.68}
};
const double nor3_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_4::power_op_ip1_rise[4][4] = {
	{125.97, 110.53, 124.83, 337.58},
	{127.59, 112.31, 122.42, 319.5},
	{127.91, 113.99, 120.92, 300.78},
	{128.13, 119.12, 119.55, 239.12}
};
const double nor3_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_4::power_op_ip2_fall[4][4] = {
	{160.65, 152.2, 175.43, 436.19},
	{160.34, 153.34, 170.52, 414.66},
	{160.98, 154.19, 167.9, 390.49},
	{162.24, 157.99, 164.4, 312.68}
};
const double nor3_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_4::power_op_ip2_rise[4][4] = {
	{125.97, 110.53, 124.83, 337.58},
	{127.59, 112.31, 122.42, 319.5},
	{127.91, 113.99, 120.92, 300.78},
	{128.13, 119.12, 119.55, 239.12}
};
const double nor3_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor3_4::power_op_ip3_fall[4][4] = {
	{160.65, 152.2, 175.43, 436.19},
	{160.34, 153.34, 170.52, 414.66},
	{160.98, 154.19, 167.9, 390.49},
	{162.24, 157.99, 164.4, 312.68}
};
const double nor3_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor3_4::power_op_ip3_rise[4][4] = {
	{125.97, 110.53, 124.83, 337.58},
	{127.59, 112.31, 122.42, 319.5},
	{127.91, 113.99, 120.92, 300.78},
	{128.13, 119.12, 119.55, 239.12}
};
const double nor3_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor3_4::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor4_1
// PROCESS NAME: proc
void nor4_1::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

nor4_1::~nor4_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor4_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor4_1::celltype = "nor4_1";
const double nor4_1::leakage_power = 1.13863e-08;
const double nor4_1::capacitance_ip1 = 4.8341;
const double nor4_1::fanout_load_ip1 = 1;
const double nor4_1::capacitance_ip2 = 4.8781;
const double nor4_1::fanout_load_ip2 = 1;
const double nor4_1::capacitance_ip3 = 5.4539;
const double nor4_1::fanout_load_ip3 = 1;
const double nor4_1::capacitance_ip4 = 5.8703;
const double nor4_1::fanout_load_ip4 = 1;
const double nor4_1::max_capacitance_op = 250;
const double nor4_1::max_fanout_op = 50;

const double nor4_1::power_op_ip1_fall[4][4] = {
	{59.776, 57.652, 60.968, 114.65},
	{60.103, 58.287, 60.357, 102.87},
	{60.189, 58.909, 60.082, 93.769},
	{58.095, 57.612, 57.967, 74.375}
};
const double nor4_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_1::power_op_ip1_rise[4][4] = {
	{47.495, 43.013, 44.353, 87.678},
	{47.759, 44.359, 44.335, 78.435},
	{47.787, 45.236, 44.688, 70.977},
	{47.793, 46.372, 45.771, 55.924}
};
const double nor4_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_1::power_op_ip2_fall[4][4] = {
	{59.776, 57.652, 60.968, 114.65},
	{60.103, 58.287, 60.357, 102.87},
	{60.189, 58.909, 60.082, 93.769},
	{58.095, 57.612, 57.967, 74.375}
};
const double nor4_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_1::power_op_ip2_rise[4][4] = {
	{47.495, 43.013, 44.353, 87.678},
	{47.759, 44.359, 44.335, 78.435},
	{47.787, 45.236, 44.688, 70.977},
	{47.793, 46.372, 45.771, 55.924}
};
const double nor4_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_1::power_op_ip3_fall[4][4] = {
	{59.776, 57.652, 60.968, 114.65},
	{60.103, 58.287, 60.357, 102.87},
	{60.189, 58.909, 60.082, 93.769},
	{58.095, 57.612, 57.967, 74.375}
};
const double nor4_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_1::power_op_ip3_rise[4][4] = {
	{47.495, 43.013, 44.353, 87.678},
	{47.759, 44.359, 44.335, 78.435},
	{47.787, 45.236, 44.688, 70.977},
	{47.793, 46.372, 45.771, 55.924}
};
const double nor4_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_1::power_op_ip4_fall[4][4] = {
	{59.776, 57.652, 60.968, 114.65},
	{60.103, 58.287, 60.357, 102.87},
	{60.189, 58.909, 60.082, 93.769},
	{58.095, 57.612, 57.967, 74.375}
};
const double nor4_1::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_1::power_op_ip4_rise[4][4] = {
	{47.495, 43.013, 44.353, 87.678},
	{47.759, 44.359, 44.335, 78.435},
	{47.787, 45.236, 44.688, 70.977},
	{47.793, 46.372, 45.771, 55.924}
};
const double nor4_1::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nor4_1::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor4_2
// PROCESS NAME: proc
void nor4_2::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

nor4_2::~nor4_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor4_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor4_2::celltype = "nor4_2";
const double nor4_2::leakage_power = 1.30262e-08;
const double nor4_2::capacitance_ip1 = 9.5171;
const double nor4_2::fanout_load_ip1 = 2;
const double nor4_2::capacitance_ip2 = 9.5183;
const double nor4_2::fanout_load_ip2 = 2;
const double nor4_2::capacitance_ip3 = 9.5721;
const double nor4_2::fanout_load_ip3 = 2;
const double nor4_2::capacitance_ip4 = 10.011;
const double nor4_2::fanout_load_ip4 = 2;
const double nor4_2::max_capacitance_op = 250;
const double nor4_2::max_fanout_op = 50;

const double nor4_2::power_op_ip1_fall[4][4] = {
	{106.09, 102.51, 109.82, 215.68},
	{106.51, 102.84, 107.94, 201.02},
	{107.06, 103.83, 107.73, 187.12},
	{106.54, 105.09, 106.39, 151.67}
};
const double nor4_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_2::power_op_ip1_rise[4][4] = {
	{81.869, 73.827, 76.728, 161.9},
	{82.416, 75.301, 76.466, 150.29},
	{82.598, 76.606, 76.484, 139.41},
	{82.67, 79.247, 78.013, 109.81}
};
const double nor4_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_2::power_op_ip2_fall[4][4] = {
	{106.09, 102.51, 109.82, 215.68},
	{106.51, 102.84, 107.94, 201.02},
	{107.06, 103.83, 107.73, 187.12},
	{106.54, 105.09, 106.39, 151.67}
};
const double nor4_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_2::power_op_ip2_rise[4][4] = {
	{81.869, 73.827, 76.728, 161.9},
	{82.416, 75.301, 76.466, 150.29},
	{82.598, 76.606, 76.484, 139.41},
	{82.67, 79.247, 78.013, 109.81}
};
const double nor4_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_2::power_op_ip3_fall[4][4] = {
	{106.09, 102.51, 109.82, 215.68},
	{106.51, 102.84, 107.94, 201.02},
	{107.06, 103.83, 107.73, 187.12},
	{106.54, 105.09, 106.39, 151.67}
};
const double nor4_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_2::power_op_ip3_rise[4][4] = {
	{81.869, 73.827, 76.728, 161.9},
	{82.416, 75.301, 76.466, 150.29},
	{82.598, 76.606, 76.484, 139.41},
	{82.67, 79.247, 78.013, 109.81}
};
const double nor4_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_2::power_op_ip4_fall[4][4] = {
	{106.09, 102.51, 109.82, 215.68},
	{106.51, 102.84, 107.94, 201.02},
	{107.06, 103.83, 107.73, 187.12},
	{106.54, 105.09, 106.39, 151.67}
};
const double nor4_2::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_2::power_op_ip4_rise[4][4] = {
	{81.869, 73.827, 76.728, 161.9},
	{82.416, 75.301, 76.466, 150.29},
	{82.598, 76.606, 76.484, 139.41},
	{82.67, 79.247, 78.013, 109.81}
};
const double nor4_2::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nor4_2::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: nor4_4
// PROCESS NAME: proc
void nor4_4::proc()
{
	op.write(
		! ( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

nor4_4::~nor4_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void nor4_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * nor4_4::celltype = "nor4_4";
const double nor4_4::leakage_power = 7.92023e-08;
const double nor4_4::capacitance_ip1 = 9.4949;
const double nor4_4::fanout_load_ip1 = 2;
const double nor4_4::capacitance_ip2 = 9.4068;
const double nor4_4::fanout_load_ip2 = 2;
const double nor4_4::capacitance_ip3 = 9.5863;
const double nor4_4::fanout_load_ip3 = 2;
const double nor4_4::capacitance_ip4 = 9.7957;
const double nor4_4::fanout_load_ip4 = 2;
const double nor4_4::max_capacitance_op = 250;
const double nor4_4::max_fanout_op = 50;

const double nor4_4::power_op_ip1_fall[4][4] = {
	{309.41, 307.58, 318.11, 451.22},
	{305.51, 303.6, 313.54, 442.88},
	{306.82, 304.6, 314.47, 441.16},
	{313.47, 311.37, 320.6, 445.31}
};
const double nor4_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_4::power_op_ip1_rise[4][4] = {
	{320.38, 313.11, 317.08, 413.46},
	{314.4, 306.66, 311.1, 406.65},
	{312.62, 305, 309.3, 403.67},
	{308.81, 301.66, 305.2, 398.16}
};
const double nor4_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_4::power_op_ip2_fall[4][4] = {
	{309.41, 307.58, 318.11, 451.22},
	{305.51, 303.6, 313.54, 442.88},
	{306.82, 304.6, 314.47, 441.16},
	{313.47, 311.37, 320.6, 445.31}
};
const double nor4_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_4::power_op_ip2_rise[4][4] = {
	{320.38, 313.11, 317.08, 413.46},
	{314.4, 306.66, 311.1, 406.65},
	{312.62, 305, 309.3, 403.67},
	{308.81, 301.66, 305.2, 398.16}
};
const double nor4_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_4::power_op_ip3_fall[4][4] = {
	{309.41, 307.58, 318.11, 451.22},
	{305.51, 303.6, 313.54, 442.88},
	{306.82, 304.6, 314.47, 441.16},
	{313.47, 311.37, 320.6, 445.31}
};
const double nor4_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_4::power_op_ip3_rise[4][4] = {
	{320.38, 313.11, 317.08, 413.46},
	{314.4, 306.66, 311.1, 406.65},
	{312.62, 305, 309.3, 403.67},
	{308.81, 301.66, 305.2, 398.16}
};
const double nor4_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double nor4_4::power_op_ip4_fall[4][4] = {
	{309.41, 307.58, 318.11, 451.22},
	{305.51, 303.6, 313.54, 442.88},
	{306.82, 304.6, 314.47, 441.16},
	{313.47, 311.37, 320.6, 445.31}
};
const double nor4_4::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double nor4_4::power_op_ip4_rise[4][4] = {
	{320.38, 313.11, 317.08, 413.46},
	{314.4, 306.66, 311.1, 406.65},
	{312.62, 305, 309.3, 403.67},
	{308.81, 301.66, 305.2, 398.16}
};
const double nor4_4::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double nor4_4::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: or2_1
// PROCESS NAME: proc
void or2_1::proc()
{
	op.write(
		( ip1.read() | ip2.read() ) 
	);
}

or2_1::~or2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or2_1::celltype = "or2_1";
const double or2_1::leakage_power = 4.46962e-08;
const double or2_1::capacitance_ip1 = 5.366;
const double or2_1::fanout_load_ip1 = 1;
const double or2_1::capacitance_ip2 = 5.0552;
const double or2_1::fanout_load_ip2 = 1;
const double or2_1::max_capacitance_op = 250;
const double or2_1::max_fanout_op = 50;

const double or2_1::power_op_ip1_fall[4][4] = {
	{74.21, 70.804, 76.899, 145.6},
	{72.788, 69.312, 74.499, 138.27},
	{72.963, 69.141, 74.144, 135.97},
	{72.914, 69.018, 73.755, 133.53}
};
const double or2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or2_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_1::power_op_ip1_rise[4][4] = {
	{73.481, 72.688, 80.537, 167.37},
	{75.429, 73.224, 79.72, 160.89},
	{75.668, 73.36, 79.347, 157.45},
	{75.728, 73.522, 79.255, 153.71}
};
const double or2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or2_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or2_1::power_op_ip2_fall[4][4] = {
	{74.21, 70.804, 76.899, 145.6},
	{72.788, 69.312, 74.499, 138.27},
	{72.963, 69.141, 74.144, 135.97},
	{72.914, 69.018, 73.755, 133.53}
};
const double or2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or2_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_1::power_op_ip2_rise[4][4] = {
	{73.481, 72.688, 80.537, 167.37},
	{75.429, 73.224, 79.72, 160.89},
	{75.668, 73.36, 79.347, 157.45},
	{75.728, 73.522, 79.255, 153.71}
};
const double or2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or2_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or2_2
// PROCESS NAME: proc
void or2_2::proc()
{
	op.write(
		( ip1.read() | ip2.read() ) 
	);
}

or2_2::~or2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or2_2::celltype = "or2_2";
const double or2_2::leakage_power = 5.08822e-08;
const double or2_2::capacitance_ip1 = 9.9916;
const double or2_2::fanout_load_ip1 = 2;
const double or2_2::capacitance_ip2 = 10.063;
const double or2_2::fanout_load_ip2 = 2;
const double or2_2::max_capacitance_op = 250;
const double or2_2::max_fanout_op = 50;

const double or2_2::power_op_ip1_fall[4][4] = {
	{137.13, 131.6, 144.01, 282.96},
	{135.58, 128.91, 140.21, 272.07},
	{136.29, 129.36, 140.31, 268.04},
	{137.26, 130.38, 140.21, 262.21}
};
const double or2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or2_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_2::power_op_ip1_rise[4][4] = {
	{137.52, 136.55, 153.65, 330.56},
	{141.06, 137.88, 152.73, 322.1},
	{142.6, 138.53, 152.25, 315.95},
	{142.95, 139.05, 151.71, 305.86}
};
const double or2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or2_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or2_2::power_op_ip2_fall[4][4] = {
	{137.13, 131.6, 144.01, 282.96},
	{135.58, 128.91, 140.21, 272.07},
	{136.29, 129.36, 140.31, 268.04},
	{137.26, 130.38, 140.21, 262.21}
};
const double or2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or2_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_2::power_op_ip2_rise[4][4] = {
	{137.52, 136.55, 153.65, 330.56},
	{141.06, 137.88, 152.73, 322.1},
	{142.6, 138.53, 152.25, 315.95},
	{142.95, 139.05, 151.71, 305.86}
};
const double or2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or2_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or2_4
// PROCESS NAME: proc
void or2_4::proc()
{
	op.write(
		( ip1.read() | ip2.read() ) 
	);
}

or2_4::~or2_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or2_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or2_4::celltype = "or2_4";
const double or2_4::leakage_power = 7.81185e-08;
const double or2_4::capacitance_ip1 = 10.061;
const double or2_4::fanout_load_ip1 = 2;
const double or2_4::capacitance_ip2 = 10.252;
const double or2_4::fanout_load_ip2 = 2;
const double or2_4::max_capacitance_op = 250;
const double or2_4::max_fanout_op = 50;

const double or2_4::power_op_ip1_fall[4][4] = {
	{229.28, 224.56, 239.56, 399.42},
	{213.76, 208.18, 222.37, 374.09},
	{206.09, 199.2, 212.27, 355.1},
	{201.64, 194.76, 204.34, 329.7}
};
const double or2_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or2_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_4::power_op_ip1_rise[4][4] = {
	{194.49, 198.58, 222.12, 438.38},
	{194.7, 196.16, 216.12, 416.61},
	{197.66, 196.25, 213.28, 402.12},
	{200.9, 196.8, 208.97, 372.34}
};
const double or2_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or2_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or2_4::power_op_ip2_fall[4][4] = {
	{229.28, 224.56, 239.56, 399.42},
	{213.76, 208.18, 222.37, 374.09},
	{206.09, 199.2, 212.27, 355.1},
	{201.64, 194.76, 204.34, 329.7}
};
const double or2_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or2_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or2_4::power_op_ip2_rise[4][4] = {
	{194.49, 198.58, 222.12, 438.38},
	{194.7, 196.16, 216.12, 416.61},
	{197.66, 196.25, 213.28, 402.12},
	{200.9, 196.8, 208.97, 372.34}
};
const double or2_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or2_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or3_1
// PROCESS NAME: proc
void or3_1::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

or3_1::~or3_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or3_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or3_1::celltype = "or3_1";
const double or3_1::leakage_power = 4.27904e-08;
const double or3_1::capacitance_ip1 = 5.2803;
const double or3_1::fanout_load_ip1 = 1;
const double or3_1::capacitance_ip2 = 5.9795;
const double or3_1::fanout_load_ip2 = 1;
const double or3_1::capacitance_ip3 = 4.9697;
const double or3_1::fanout_load_ip3 = 1;
const double or3_1::max_capacitance_op = 250;
const double or3_1::max_fanout_op = 50;

const double or3_1::power_op_ip1_fall[4][4] = {
	{104.67, 100.39, 103.88, 162.75},
	{97.666, 93.256, 96.137, 151.67},
	{96.324, 91.909, 94.444, 147.45},
	{94.737, 90.413, 92.657, 143.06}
};
const double or3_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_1::power_op_ip1_rise[4][4] = {
	{96.913, 96.062, 102.68, 180.6},
	{98.876, 96.687, 101.51, 172.3},
	{99.58, 97.057, 101.27, 168.29},
	{100.17, 97.782, 101.63, 163.97}
};
const double or3_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_1::power_op_ip2_fall[4][4] = {
	{104.67, 100.39, 103.88, 162.75},
	{97.666, 93.256, 96.137, 151.67},
	{96.324, 91.909, 94.444, 147.45},
	{94.737, 90.413, 92.657, 143.06}
};
const double or3_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_1::power_op_ip2_rise[4][4] = {
	{96.913, 96.062, 102.68, 180.6},
	{98.876, 96.687, 101.51, 172.3},
	{99.58, 97.057, 101.27, 168.29},
	{100.17, 97.782, 101.63, 163.97}
};
const double or3_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_1::power_op_ip3_fall[4][4] = {
	{104.67, 100.39, 103.88, 162.75},
	{97.666, 93.256, 96.137, 151.67},
	{96.324, 91.909, 94.444, 147.45},
	{94.737, 90.413, 92.657, 143.06}
};
const double or3_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_1::power_op_ip3_rise[4][4] = {
	{96.913, 96.062, 102.68, 180.6},
	{98.876, 96.687, 101.51, 172.3},
	{99.58, 97.057, 101.27, 168.29},
	{100.17, 97.782, 101.63, 163.97}
};
const double or3_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or3_1::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or3_2
// PROCESS NAME: proc
void or3_2::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

or3_2::~or3_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or3_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or3_2::celltype = "or3_2";
const double or3_2::leakage_power = 4.71587e-08;
const double or3_2::capacitance_ip1 = 9.7876;
const double or3_2::fanout_load_ip1 = 2;
const double or3_2::capacitance_ip2 = 10.03;
const double or3_2::fanout_load_ip2 = 2;
const double or3_2::capacitance_ip3 = 9.6837;
const double or3_2::fanout_load_ip3 = 2;
const double or3_2::max_capacitance_op = 250;
const double or3_2::max_fanout_op = 50;

const double or3_2::power_op_ip1_fall[4][4] = {
	{171.77, 164.43, 171.5, 286.52},
	{162.73, 154.99, 161.6, 272.22},
	{160.63, 152.74, 158.45, 264.98},
	{157.98, 150.16, 155.08, 255.45}
};
const double or3_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_2::power_op_ip1_rise[4][4] = {
	{163.52, 162.59, 175.84, 327.71},
	{166.09, 163.08, 174.2, 317.49},
	{167.53, 163.53, 173.35, 310.65},
	{168.25, 164.25, 172.61, 298.93}
};
const double or3_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_2::power_op_ip2_fall[4][4] = {
	{171.77, 164.43, 171.5, 286.52},
	{162.73, 154.99, 161.6, 272.22},
	{160.63, 152.74, 158.45, 264.98},
	{157.98, 150.16, 155.08, 255.45}
};
const double or3_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_2::power_op_ip2_rise[4][4] = {
	{163.52, 162.59, 175.84, 327.71},
	{166.09, 163.08, 174.2, 317.49},
	{167.53, 163.53, 173.35, 310.65},
	{168.25, 164.25, 172.61, 298.93}
};
const double or3_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_2::power_op_ip3_fall[4][4] = {
	{171.77, 164.43, 171.5, 286.52},
	{162.73, 154.99, 161.6, 272.22},
	{160.63, 152.74, 158.45, 264.98},
	{157.98, 150.16, 155.08, 255.45}
};
const double or3_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_2::power_op_ip3_rise[4][4] = {
	{163.52, 162.59, 175.84, 327.71},
	{166.09, 163.08, 174.2, 317.49},
	{167.53, 163.53, 173.35, 310.65},
	{168.25, 164.25, 172.61, 298.93}
};
const double or3_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or3_2::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or3_4
// PROCESS NAME: proc
void or3_4::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() ) 
	);
}

or3_4::~or3_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or3_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or3_4::celltype = "or3_4";
const double or3_4::leakage_power = 7.60304e-08;
const double or3_4::capacitance_ip1 = 9.7866;
const double or3_4::fanout_load_ip1 = 2;
const double or3_4::capacitance_ip2 = 10.075;
const double or3_4::fanout_load_ip2 = 2;
const double or3_4::capacitance_ip3 = 9.6895;
const double or3_4::fanout_load_ip3 = 2;
const double or3_4::max_capacitance_op = 250;
const double or3_4::max_fanout_op = 50;

const double or3_4::power_op_ip1_fall[4][4] = {
	{291.31, 284.26, 292.69, 422.41},
	{268.1, 260.18, 268.2, 394.58},
	{249.61, 242.47, 250.3, 371.41},
	{227.41, 219.99, 225.46, 331.17}
};
const double or3_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_4::power_op_ip1_rise[4][4] = {
	{218.27, 222.4, 243.91, 437.25},
	{216.91, 218.55, 236.45, 414.68},
	{218.48, 218.24, 233.13, 399.05},
	{220.74, 217.04, 226.58, 365.96}
};
const double or3_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_4::power_op_ip2_fall[4][4] = {
	{291.31, 284.26, 292.69, 422.41},
	{268.1, 260.18, 268.2, 394.58},
	{249.61, 242.47, 250.3, 371.41},
	{227.41, 219.99, 225.46, 331.17}
};
const double or3_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_4::power_op_ip2_rise[4][4] = {
	{218.27, 222.4, 243.91, 437.25},
	{216.91, 218.55, 236.45, 414.68},
	{218.48, 218.24, 233.13, 399.05},
	{220.74, 217.04, 226.58, 365.96}
};
const double or3_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or3_4::power_op_ip3_fall[4][4] = {
	{291.31, 284.26, 292.69, 422.41},
	{268.1, 260.18, 268.2, 394.58},
	{249.61, 242.47, 250.3, 371.41},
	{227.41, 219.99, 225.46, 331.17}
};
const double or3_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or3_4::power_op_ip3_rise[4][4] = {
	{218.27, 222.4, 243.91, 437.25},
	{216.91, 218.55, 236.45, 414.68},
	{218.48, 218.24, 233.13, 399.05},
	{220.74, 217.04, 226.58, 365.96}
};
const double or3_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or3_4::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or4_1
// PROCESS NAME: proc
void or4_1::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

or4_1::~or4_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or4_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or4_1::celltype = "or4_1";
const double or4_1::leakage_power = 3.94734e-08;
const double or4_1::capacitance_ip1 = 4.8753;
const double or4_1::fanout_load_ip1 = 1;
const double or4_1::capacitance_ip2 = 5.9727;
const double or4_1::fanout_load_ip2 = 1;
const double or4_1::capacitance_ip3 = 5.6996;
const double or4_1::fanout_load_ip3 = 1;
const double or4_1::capacitance_ip4 = 5.0409;
const double or4_1::fanout_load_ip4 = 1;
const double or4_1::max_capacitance_op = 250;
const double or4_1::max_fanout_op = 50;

const double or4_1::power_op_ip1_fall[4][4] = {
	{124.23, 119.97, 121.63, 169.12},
	{113.19, 108.85, 110.14, 155.5},
	{109.2, 104.74, 105.86, 149.23},
	{104.51, 100.04, 100.97, 142.05}
};
const double or4_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_1::power_op_ip1_rise[4][4] = {
	{109.2, 108.45, 114.05, 181.29},
	{110.64, 108.59, 112.45, 172.78},
	{111.24, 108.91, 112.09, 168.59},
	{111.73, 109.52, 112.21, 163.85}
};
const double or4_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_1::power_op_ip2_fall[4][4] = {
	{124.23, 119.97, 121.63, 169.12},
	{113.19, 108.85, 110.14, 155.5},
	{109.2, 104.74, 105.86, 149.23},
	{104.51, 100.04, 100.97, 142.05}
};
const double or4_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_1::power_op_ip2_rise[4][4] = {
	{109.2, 108.45, 114.05, 181.29},
	{110.64, 108.59, 112.45, 172.78},
	{111.24, 108.91, 112.09, 168.59},
	{111.73, 109.52, 112.21, 163.85}
};
const double or4_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_1::power_op_ip3_fall[4][4] = {
	{124.23, 119.97, 121.63, 169.12},
	{113.19, 108.85, 110.14, 155.5},
	{109.2, 104.74, 105.86, 149.23},
	{104.51, 100.04, 100.97, 142.05}
};
const double or4_1::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_1::power_op_ip3_rise[4][4] = {
	{109.2, 108.45, 114.05, 181.29},
	{110.64, 108.59, 112.45, 172.78},
	{111.24, 108.91, 112.09, 168.59},
	{111.73, 109.52, 112.21, 163.85}
};
const double or4_1::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_1::power_op_ip4_fall[4][4] = {
	{124.23, 119.97, 121.63, 169.12},
	{113.19, 108.85, 110.14, 155.5},
	{109.2, 104.74, 105.86, 149.23},
	{104.51, 100.04, 100.97, 142.05}
};
const double or4_1::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_1::power_op_ip4_rise[4][4] = {
	{109.2, 108.45, 114.05, 181.29},
	{110.64, 108.59, 112.45, 172.78},
	{111.24, 108.91, 112.09, 168.59},
	{111.73, 109.52, 112.21, 163.85}
};
const double or4_1::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double or4_1::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or4_2
// PROCESS NAME: proc
void or4_2::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

or4_2::~or4_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or4_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or4_2::celltype = "or4_2";
const double or4_2::leakage_power = 4.27152e-08;
const double or4_2::capacitance_ip1 = 10.078;
const double or4_2::fanout_load_ip1 = 2;
const double or4_2::capacitance_ip2 = 9.666;
const double or4_2::fanout_load_ip2 = 2;
const double or4_2::capacitance_ip3 = 9.4696;
const double or4_2::fanout_load_ip3 = 2;
const double or4_2::capacitance_ip4 = 9.463;
const double or4_2::fanout_load_ip4 = 2;
const double or4_2::max_capacitance_op = 250;
const double or4_2::max_fanout_op = 50;

const double or4_2::power_op_ip1_fall[4][4] = {
	{202.58, 194.88, 198.9, 292.39},
	{188.56, 180.92, 184.51, 275.5},
	{181.88, 173.93, 177.17, 265.27},
	{173.92, 165.93, 168.37, 250.8}
};
const double or4_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_2::power_op_ip1_rise[4][4] = {
	{183.79, 183.12, 194.2, 325.93},
	{185.96, 183.38, 192.17, 315.23},
	{187.26, 183.7, 191.17, 307.99},
	{188.11, 184.22, 190.3, 295.9}
};
const double or4_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_2::power_op_ip2_fall[4][4] = {
	{202.58, 194.88, 198.9, 292.39},
	{188.56, 180.92, 184.51, 275.5},
	{181.88, 173.93, 177.17, 265.27},
	{173.92, 165.93, 168.37, 250.8}
};
const double or4_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_2::power_op_ip2_rise[4][4] = {
	{183.79, 183.12, 194.2, 325.93},
	{185.96, 183.38, 192.17, 315.23},
	{187.26, 183.7, 191.17, 307.99},
	{188.11, 184.22, 190.3, 295.9}
};
const double or4_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_2::power_op_ip3_fall[4][4] = {
	{202.58, 194.88, 198.9, 292.39},
	{188.56, 180.92, 184.51, 275.5},
	{181.88, 173.93, 177.17, 265.27},
	{173.92, 165.93, 168.37, 250.8}
};
const double or4_2::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_2::power_op_ip3_rise[4][4] = {
	{183.79, 183.12, 194.2, 325.93},
	{185.96, 183.38, 192.17, 315.23},
	{187.26, 183.7, 191.17, 307.99},
	{188.11, 184.22, 190.3, 295.9}
};
const double or4_2::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_2::power_op_ip4_fall[4][4] = {
	{202.58, 194.88, 198.9, 292.39},
	{188.56, 180.92, 184.51, 275.5},
	{181.88, 173.93, 177.17, 265.27},
	{173.92, 165.93, 168.37, 250.8}
};
const double or4_2::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_2::power_op_ip4_rise[4][4] = {
	{183.79, 183.12, 194.2, 325.93},
	{185.96, 183.38, 192.17, 315.23},
	{187.26, 183.7, 191.17, 307.99},
	{188.11, 184.22, 190.3, 295.9}
};
const double or4_2::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double or4_2::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: or4_4
// PROCESS NAME: proc
void or4_4::proc()
{
	op.write(
		( ip1.read() | ip2.read() | ip3.read() | ip4.read() ) 
	);
}

or4_4::~or4_4()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void or4_4::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * or4_4::celltype = "or4_4";
const double or4_4::leakage_power = 7.24041e-08;
const double or4_4::capacitance_ip1 = 10.089;
const double or4_4::fanout_load_ip1 = 2;
const double or4_4::capacitance_ip2 = 9.6906;
const double or4_4::fanout_load_ip2 = 2;
const double or4_4::capacitance_ip3 = 9.4618;
const double or4_4::fanout_load_ip3 = 2;
const double or4_4::capacitance_ip4 = 9.599;
const double or4_4::fanout_load_ip4 = 2;
const double or4_4::max_capacitance_op = 250;
const double or4_4::max_fanout_op = 50;

const double or4_4::power_op_ip1_fall[4][4] = {
	{359.44, 352.03, 356.29, 460.54},
	{331.46, 324.77, 328.4, 430.24},
	{306.46, 298.88, 302.41, 401.72},
	{260.1, 252.38, 254.93, 341.79}
};
const double or4_4::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_4::power_op_ip1_rise[4][4] = {
	{240.34, 244.22, 264.2, 440.75},
	{237.81, 239.9, 255.78, 416.72},
	{238.74, 238.63, 251.98, 399.91},
	{240.66, 237.05, 244.59, 365.03}
};
const double or4_4::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_4::power_op_ip2_fall[4][4] = {
	{359.44, 352.03, 356.29, 460.54},
	{331.46, 324.77, 328.4, 430.24},
	{306.46, 298.88, 302.41, 401.72},
	{260.1, 252.38, 254.93, 341.79}
};
const double or4_4::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_4::power_op_ip2_rise[4][4] = {
	{240.34, 244.22, 264.2, 440.75},
	{237.81, 239.9, 255.78, 416.72},
	{238.74, 238.63, 251.98, 399.91},
	{240.66, 237.05, 244.59, 365.03}
};
const double or4_4::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_4::power_op_ip3_fall[4][4] = {
	{359.44, 352.03, 356.29, 460.54},
	{331.46, 324.77, 328.4, 430.24},
	{306.46, 298.88, 302.41, 401.72},
	{260.1, 252.38, 254.93, 341.79}
};
const double or4_4::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_4::power_op_ip3_rise[4][4] = {
	{240.34, 244.22, 264.2, 440.75},
	{237.81, 239.9, 255.78, 416.72},
	{238.74, 238.63, 251.98, 399.91},
	{240.66, 237.05, 244.59, 365.03}
};
const double or4_4::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double or4_4::power_op_ip4_fall[4][4] = {
	{359.44, 352.03, 356.29, 460.54},
	{331.46, 324.77, 328.4, 430.24},
	{306.46, 298.88, 302.41, 401.72},
	{260.1, 252.38, 254.93, 341.79}
};
const double or4_4::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double or4_4::power_op_ip4_rise[4][4] = {
	{240.34, 244.22, 264.2, 440.75},
	{237.81, 239.9, 255.78, 416.72},
	{238.74, 238.63, 251.98, 399.91},
	{240.66, 237.05, 244.59, 365.03}
};
const double or4_4::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double or4_4::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: xnor2_1
// PROCESS NAME: proc
void xnor2_1::proc()
{
	op.write(
		( ( ! ip1.read() & ! ip2.read() ) | ( ip1.read() & ip2.read() ) ) 
	);
}

xnor2_1::~xnor2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void xnor2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * xnor2_1::celltype = "xnor2_1";
const double xnor2_1::leakage_power = 9.90037e-08;
const double xnor2_1::capacitance_ip1 = 11.099;
const double xnor2_1::fanout_load_ip1 = 2;
const double xnor2_1::capacitance_ip2 = 9.0743;
const double xnor2_1::fanout_load_ip2 = 2;
const double xnor2_1::max_capacitance_op = 250;
const double xnor2_1::max_fanout_op = 50;

const double xnor2_1::power_op_ip1_fall[4][4] = {
	{137.28, 133.1, 144.6, 268.12},
	{134.17, 129.97, 141.03, 261.19},
	{134.47, 130.22, 140.94, 259.66},
	{134.48, 130.19, 141.02, 258.31}
};
const double xnor2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double xnor2_1::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double xnor2_1::power_op_ip1_rise[4][4] = {
	{133.68, 130.91, 143.59, 275.45},
	{133.99, 130.64, 142.52, 270.61},
	{134.51, 131.05, 142.74, 268.8},
	{135.32, 131.8, 143.75, 267.26}
};
const double xnor2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double xnor2_1::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double xnor2_1::power_op_ip2_fall[4][4] = {
	{137.28, 133.1, 144.6, 268.12},
	{134.17, 129.97, 141.03, 261.19},
	{134.47, 130.22, 140.94, 259.66},
	{134.48, 130.19, 141.02, 258.31}
};
const double xnor2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double xnor2_1::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double xnor2_1::power_op_ip2_rise[4][4] = {
	{133.68, 130.91, 143.59, 275.45},
	{133.99, 130.64, 142.52, 270.61},
	{134.51, 131.05, 142.74, 268.8},
	{135.32, 131.8, 143.75, 267.26}
};
const double xnor2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double xnor2_1::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: xnor2_2
// PROCESS NAME: proc
void xnor2_2::proc()
{
	op.write(
		( ( ! ip1.read() & ! ip2.read() ) | ( ip1.read() & ip2.read() ) ) 
	);
}

xnor2_2::~xnor2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void xnor2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * xnor2_2::celltype = "xnor2_2";
const double xnor2_2::leakage_power = 1.02789e-07;
const double xnor2_2::capacitance_ip1 = 11.164;
const double xnor2_2::fanout_load_ip1 = 2;
const double xnor2_2::capacitance_ip2 = 9.3214;
const double xnor2_2::fanout_load_ip2 = 2;
const double xnor2_2::max_capacitance_op = 250;
const double xnor2_2::max_fanout_op = 50;

const double xnor2_2::power_op_ip1_fall[4][4] = {
	{186.1, 182.22, 194.04, 323.13},
	{173.78, 170.26, 181.79, 306.99},
	{170.79, 166.71, 177.89, 299.88},
	{167.9, 163.76, 174.49, 291.98}
};
const double xnor2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double xnor2_2::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double xnor2_2::power_op_ip1_rise[4][4] = {
	{170.58, 168.66, 182.17, 323.73},
	{166.5, 163.9, 176.63, 312.71},
	{165.73, 162.64, 174.84, 307.04},
	{165.05, 161.82, 173.18, 298.56}
};
const double xnor2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double xnor2_2::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double xnor2_2::power_op_ip2_fall[4][4] = {
	{186.1, 182.22, 194.04, 323.13},
	{173.78, 170.26, 181.79, 306.99},
	{170.79, 166.71, 177.89, 299.88},
	{167.9, 163.76, 174.49, 291.98}
};
const double xnor2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double xnor2_2::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double xnor2_2::power_op_ip2_rise[4][4] = {
	{170.58, 168.66, 182.17, 323.73},
	{166.5, 163.9, 176.63, 312.71},
	{165.73, 162.64, 174.84, 307.04},
	{165.05, 161.82, 173.18, 298.56}
};
const double xnor2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double xnor2_2::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: xor2_1
// PROCESS NAME: proc
void xor2_1::proc()
{
	op.write(
		( ( ip1.read() & ! ip2.read() ) | ( ! ip1.read() & ip2.read() ) ) 
	);
}

xor2_1::~xor2_1()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void xor2_1::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * xor2_1::celltype = "xor2_1";
const double xor2_1::leakage_power = 7.88197e-08;
const double xor2_1::capacitance_ip1 = 11.508;
const double xor2_1::fanout_load_ip1 = 2;
const double xor2_1::capacitance_ip2 = 9.3332;
const double xor2_1::fanout_load_ip2 = 2;
const double xor2_1::max_capacitance_op = 250;
const double xor2_1::max_fanout_op = 50;

const double xor2_1::power_op_ip1_fall[4][4] = {
	{87.608, 83.739, 95.938, 221.52},
	{87.326, 84.392, 95.136, 212.33},
	{87.111, 84.449, 94.175, 204.86},
	{86.455, 83.968, 93.077, 190.57}
};
const double xor2_1::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double xor2_1::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double xor2_1::power_op_ip1_rise[4][4] = {
	{84.308, 79.597, 90.804, 210.21},
	{83.466, 79.797, 89.787, 201.25},
	{82.867, 79.63, 89.091, 194.89},
	{81.905, 79.091, 87.854, 182.55}
};
const double xor2_1::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double xor2_1::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double xor2_1::power_op_ip2_fall[4][4] = {
	{87.608, 83.739, 95.938, 221.52},
	{87.326, 84.392, 95.136, 212.33},
	{87.111, 84.449, 94.175, 204.86},
	{86.455, 83.968, 93.077, 190.57}
};
const double xor2_1::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double xor2_1::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double xor2_1::power_op_ip2_rise[4][4] = {
	{84.308, 79.597, 90.804, 210.21},
	{83.466, 79.797, 89.787, 201.25},
	{82.867, 79.63, 89.091, 194.89},
	{81.905, 79.091, 87.854, 182.55}
};
const double xor2_1::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double xor2_1::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: xor2_2
// PROCESS NAME: proc
void xor2_2::proc()
{
	op.write(
		( ( ip1.read() & ! ip2.read() ) | ( ! ip1.read() & ip2.read() ) ) 
	);
}

xor2_2::~xor2_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	PSC_INSERT_CELL(info);
#endif
}

void xor2_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * xor2_2::celltype = "xor2_2";
const double xor2_2::leakage_power = 9.30815e-08;
const double xor2_2::capacitance_ip1 = 20.244;
const double xor2_2::fanout_load_ip1 = 4;
const double xor2_2::capacitance_ip2 = 17.053;
const double xor2_2::fanout_load_ip2 = 3;
const double xor2_2::max_capacitance_op = 250;
const double xor2_2::max_fanout_op = 50;

const double xor2_2::power_op_ip1_fall[4][4] = {
	{152.27, 145.62, 171.31, 415.47},
	{151.95, 146.55, 169.92, 404.19},
	{151.69, 147.13, 168.61, 393.71},
	{150.71, 146.43, 165.76, 365.95}
};
const double xor2_2::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double xor2_2::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double xor2_2::power_op_ip1_rise[4][4] = {
	{145.5, 137.22, 160.57, 393.15},
	{144.78, 137.93, 159.11, 382.22},
	{143.69, 137.79, 158.07, 372.29},
	{140.73, 136.79, 155.29, 348.51}
};
const double xor2_2::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double xor2_2::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double xor2_2::power_op_ip2_fall[4][4] = {
	{152.27, 145.62, 171.31, 415.47},
	{151.95, 146.55, 169.92, 404.19},
	{151.69, 147.13, 168.61, 393.71},
	{150.71, 146.43, 165.76, 365.95}
};
const double xor2_2::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double xor2_2::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double xor2_2::power_op_ip2_rise[4][4] = {
	{145.5, 137.22, 160.57, 393.15},
	{144.78, 137.93, 159.11, 382.22},
	{143.69, 137.79, 158.07, 372.29},
	{140.73, 136.79, 155.29, 348.51}
};
const double xor2_2::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double xor2_2::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: ABorC
// PROCESS NAME: proc
void ABorC::proc()
{
	op.write(
		( ( ip1.read() & ip2.read() ) | ip3.read() ) 
	);
}

ABorC::~ABorC()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	PSC_INSERT_CELL(info);
#endif
}

void ABorC::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * ABorC::celltype = "ABorC";
const double ABorC::leakage_power = 4.72504e-08;
const double ABorC::capacitance_ip1 = 4.4849;
const double ABorC::fanout_load_ip1 = 1;
const double ABorC::capacitance_ip2 = 4.6715;
const double ABorC::fanout_load_ip2 = 1;
const double ABorC::capacitance_ip3 = 4.4962;
const double ABorC::fanout_load_ip3 = 1;
const double ABorC::max_capacitance_op = 250;
const double ABorC::max_fanout_op = 50;

const double ABorC::power_op_ip1_fall[4][4] = {
	{35.949, 36.759, 62.641, 35.043},
	{38.059, 36.585, 61.532, 34.852},
	{66.146, 36.378, 60.247, 35.903},
	{35.018, 37.981, 66.14, 35.015}
};
const double ABorC::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double ABorC::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double ABorC::power_op_ip1_rise[4][4] = {
	{18.323, 10.265, 32.84, 16.166},
	{20.956, 18.319, 20.907, 45.032},
	{45.042, 8.1016, 10.23, 32.826},
	{8.0732, 16.168, 0, 0}
};
const double ABorC::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double ABorC::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: ab_or_c_or_d
// PROCESS NAME: proc
void ab_or_c_or_d::proc()
{
	op.write(
		( ( ip1.read() & ip2.read() ) | ip3.read() | ip4.read() ) 
	);
}

ab_or_c_or_d::~ab_or_c_or_d()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void ab_or_c_or_d::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * ab_or_c_or_d::celltype = "ab_or_c_or_d";
const double ab_or_c_or_d::leakage_power = 4.62263e-08;
const double ab_or_c_or_d::capacitance_ip1 = 4.8183;
const double ab_or_c_or_d::fanout_load_ip1 = 1;
const double ab_or_c_or_d::capacitance_ip2 = 5.0355;
const double ab_or_c_or_d::fanout_load_ip2 = 1;
const double ab_or_c_or_d::capacitance_ip3 = 4.9561;
const double ab_or_c_or_d::fanout_load_ip3 = 1;
const double ab_or_c_or_d::capacitance_ip4 = 4.7298;
const double ab_or_c_or_d::fanout_load_ip4 = 1;
const double ab_or_c_or_d::max_capacitance_op = 250;
const double ab_or_c_or_d::max_fanout_op = 50;

const double ab_or_c_or_d::power_op_ip1_fall[4][4] = {
	{116.55, 113.5, 113.53, 168.24},
	{108.94, 106, 105.63, 157.01},
	{107.05, 103.82, 103.34, 152.15},
	{104.35, 101.11, 100.49, 146.06}
};
const double ab_or_c_or_d::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip1_fall[4] = {0, 59.722, 125.27, 578.29};

const double ab_or_c_or_d::power_op_ip1_rise[4][4] = {
	{124.34, 120.88, 125.56, 208.68},
	{121.53, 117.87, 121.53, 198.34},
	{120.58, 116.74, 119.98, 192.85},
	{119.95, 115.91, 118.61, 185.23}
};
const double ab_or_c_or_d::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double ab_or_c_or_d::power_op_ip2_fall[4][4] = {
	{104.68, 100.46, 100.31, 152.87},
	{98.978, 94.472, 94.086, 142.32},
	{97.575, 93.446, 92.525, 138.16},
	{95.875, 91.592, 90.71, 132.98}
};
const double ab_or_c_or_d::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip2_fall[4] = {0, 59.722, 125.27, 578.29};

const double ab_or_c_or_d::power_op_ip2_rise[4][4] = {
	{119.59, 117.41, 123.39, 204.81},
	{116.73, 114.09, 118.92, 194.13},
	{115.84, 112.88, 116.89, 188},
	{115.12, 112.03, 115.11, 179.06}
};
const double ab_or_c_or_d::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double ab_or_c_or_d::power_op_ip3_fall[4][4] = {
	{87.592, 83.828, 87.665, 153.71},
	{83.85, 79.906, 83.005, 144.52},
	{83.325, 79.253, 82.097, 141.58},
	{82.386, 78.336, 80.955, 137.81}
};
const double ab_or_c_or_d::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip3_fall[4] = {0, 59.722, 125.27, 578.29};

const double ab_or_c_or_d::power_op_ip3_rise[4][4] = {
	{87.735, 87.746, 95.74, 180.84},
	{88.887, 87.833, 94.091, 173.29},
	{89.117, 87.526, 93.346, 168.97},
	{89.221, 87.614, 92.93, 163.93}
};
const double ab_or_c_or_d::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double ab_or_c_or_d::power_op_ip4_fall[4][4] = {
	{78.937, 77.959, 84.252, 142.96},
	{75.101, 73.953, 79.741, 134.77},
	{74.789, 73.243, 78.595, 131.58},
	{73.847, 72.514, 77.511, 128.18}
};
const double ab_or_c_or_d::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip4_fall[4] = {0, 59.722, 125.27, 578.29};

const double ab_or_c_or_d::power_op_ip4_rise[4][4] = {
	{70.931, 72.661, 79.208, 153.54},
	{73.021, 73.189, 78.486, 146.8},
	{73.315, 73.374, 78.214, 143.46},
	{73.333, 73.484, 78.151, 139.85}
};
const double ab_or_c_or_d::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double ab_or_c_or_d::col_op_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: fulladder
// PROCESS NAME: proc
void fulladder::proc()
{
	s.write(
		( a.read() & ! b.read() & ! ci.read() ) | ( ! a.read() & b.read() & ! ci.read() ) | ( ! a.read() & ! b.read() & ci.read() ) | ( a.read() & b.read() & ci.read() ) 
	);
	co.write(
		( a.read() & b.read() ) | ( b.read() & ci.read() ) | ( a.read() & ci.read() ) 
	);
}

fulladder::~fulladder()
{
#ifdef POWER_SIM

	sc_interface *_if_a = a.get_interface();
	psc_objinfo_if *_p_a = dynamic_cast<psc_objinfo_if*>(_if_a);

	sc_interface *_if_b = b.get_interface();
	psc_objinfo_if *_p_b = dynamic_cast<psc_objinfo_if*>(_if_b);

	sc_interface *_if_ci = ci.get_interface();
	psc_objinfo_if *_p_ci = dynamic_cast<psc_objinfo_if*>(_if_ci);

	sc_interface *_if_s = s.get_interface();
	psc_objinfo_if *_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);

	sc_interface *_if_co = co.get_interface();
	psc_objinfo_if *_p_co = dynamic_cast<psc_objinfo_if*>(_if_co);

	int i, j;
	bool p_set;

	psc_point_t pts_s_a[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_s->get_net_load() < lin_s_a[i])
			for (j=1 ; j<4 ; j++)
				if (_p_a->get_net_delay() < col_s_a[j]) {
					pts_s_a[0].y = col_s_a[j-1];
					pts_s_a[0].x = lin_s_a[i-1];
					pts_s_a[0].z = power_s_a[i-1][j-1];

					pts_s_a[1].y = col_s_a[j];
					pts_s_a[1].x = lin_s_a[i-1];
					pts_s_a[1].z = power_s_a[i-1][j];

					pts_s_a[2].y = col_s_a[j];
					pts_s_a[2].x = lin_s_a[i];
					pts_s_a[2].z = power_s_a[i][j];

					pts_s_a[3].y = col_s_a[j-1];
					pts_s_a[3].x = lin_s_a[i];
					pts_s_a[3].z = power_s_a[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_a = psc_geometric_centroid(pts_s_a, _p_s->get_net_load(), _p_a->get_net_delay());

	psc_point_t pts_s_b[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_s->get_net_load() < lin_s_b[i])
			for (j=1 ; j<4 ; j++)
				if (_p_b->get_net_delay() < col_s_b[j]) {
					pts_s_b[0].y = col_s_b[j-1];
					pts_s_b[0].x = lin_s_b[i-1];
					pts_s_b[0].z = power_s_b[i-1][j-1];

					pts_s_b[1].y = col_s_b[j];
					pts_s_b[1].x = lin_s_b[i-1];
					pts_s_b[1].z = power_s_b[i-1][j];

					pts_s_b[2].y = col_s_b[j];
					pts_s_b[2].x = lin_s_b[i];
					pts_s_b[2].z = power_s_b[i][j];

					pts_s_b[3].y = col_s_b[j-1];
					pts_s_b[3].x = lin_s_b[i];
					pts_s_b[3].z = power_s_b[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_b = psc_geometric_centroid(pts_s_b, _p_s->get_net_load(), _p_b->get_net_delay());

	psc_point_t pts_s_ci[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_s->get_net_load() < lin_s_ci[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ci->get_net_delay() < col_s_ci[j]) {
					pts_s_ci[0].y = col_s_ci[j-1];
					pts_s_ci[0].x = lin_s_ci[i-1];
					pts_s_ci[0].z = power_s_ci[i-1][j-1];

					pts_s_ci[1].y = col_s_ci[j];
					pts_s_ci[1].x = lin_s_ci[i-1];
					pts_s_ci[1].z = power_s_ci[i-1][j];

					pts_s_ci[2].y = col_s_ci[j];
					pts_s_ci[2].x = lin_s_ci[i];
					pts_s_ci[2].z = power_s_ci[i][j];

					pts_s_ci[3].y = col_s_ci[j-1];
					pts_s_ci[3].x = lin_s_ci[i];
					pts_s_ci[3].z = power_s_ci[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s_ci = psc_geometric_centroid(pts_s_ci, _p_s->get_net_load(), _p_ci->get_net_delay());

	psc_point_t pts_co_a[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_co->get_net_load() < lin_co_a[i])
			for (j=1 ; j<4 ; j++)
				if (_p_a->get_net_delay() < col_co_a[j]) {
					pts_co_a[0].y = col_co_a[j-1];
					pts_co_a[0].x = lin_co_a[i-1];
					pts_co_a[0].z = power_co_a[i-1][j-1];

					pts_co_a[1].y = col_co_a[j];
					pts_co_a[1].x = lin_co_a[i-1];
					pts_co_a[1].z = power_co_a[i-1][j];

					pts_co_a[2].y = col_co_a[j];
					pts_co_a[2].x = lin_co_a[i];
					pts_co_a[2].z = power_co_a[i][j];

					pts_co_a[3].y = col_co_a[j-1];
					pts_co_a[3].x = lin_co_a[i];
					pts_co_a[3].z = power_co_a[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_co_a = psc_geometric_centroid(pts_co_a, _p_co->get_net_load(), _p_a->get_net_delay());

	psc_point_t pts_co_b[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_co->get_net_load() < lin_co_b[i])
			for (j=1 ; j<4 ; j++)
				if (_p_b->get_net_delay() < col_co_b[j]) {
					pts_co_b[0].y = col_co_b[j-1];
					pts_co_b[0].x = lin_co_b[i-1];
					pts_co_b[0].z = power_co_b[i-1][j-1];

					pts_co_b[1].y = col_co_b[j];
					pts_co_b[1].x = lin_co_b[i-1];
					pts_co_b[1].z = power_co_b[i-1][j];

					pts_co_b[2].y = col_co_b[j];
					pts_co_b[2].x = lin_co_b[i];
					pts_co_b[2].z = power_co_b[i][j];

					pts_co_b[3].y = col_co_b[j-1];
					pts_co_b[3].x = lin_co_b[i];
					pts_co_b[3].z = power_co_b[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_co_b = psc_geometric_centroid(pts_co_b, _p_co->get_net_load(), _p_b->get_net_delay());

	psc_point_t pts_co_ci[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_co->get_net_load() < lin_co_ci[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ci->get_net_delay() < col_co_ci[j]) {
					pts_co_ci[0].y = col_co_ci[j-1];
					pts_co_ci[0].x = lin_co_ci[i-1];
					pts_co_ci[0].z = power_co_ci[i-1][j-1];

					pts_co_ci[1].y = col_co_ci[j];
					pts_co_ci[1].x = lin_co_ci[i-1];
					pts_co_ci[1].z = power_co_ci[i-1][j];

					pts_co_ci[2].y = col_co_ci[j];
					pts_co_ci[2].x = lin_co_ci[i];
					pts_co_ci[2].z = power_co_ci[i][j];

					pts_co_ci[3].y = col_co_ci[j-1];
					pts_co_ci[3].x = lin_co_ci[i];
					pts_co_ci[3].z = power_co_ci[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_co_ci = psc_geometric_centroid(pts_co_ci, _p_co->get_net_load(), _p_ci->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_s_a(_p_s->get_id(), E_s_a);
	pwr_s_a.set_rel_pins(1, _p_a->get_id().c_str());
	info.add(pwr_s_a);
	psc_pin_power_info pwr_s_b(_p_s->get_id(), E_s_b);
	pwr_s_b.set_rel_pins(1, _p_b->get_id().c_str());
	info.add(pwr_s_b);
	psc_pin_power_info pwr_s_ci(_p_s->get_id(), E_s_ci);
	pwr_s_ci.set_rel_pins(1, _p_ci->get_id().c_str());
	info.add(pwr_s_ci);
	psc_pin_power_info pwr_co_a(_p_co->get_id(), E_co_a);
	pwr_co_a.set_rel_pins(1, _p_a->get_id().c_str());
	info.add(pwr_co_a);
	psc_pin_power_info pwr_co_b(_p_co->get_id(), E_co_b);
	pwr_co_b.set_rel_pins(1, _p_b->get_id().c_str());
	info.add(pwr_co_b);
	psc_pin_power_info pwr_co_ci(_p_co->get_id(), E_co_ci);
	pwr_co_ci.set_rel_pins(1, _p_ci->get_id().c_str());
	info.add(pwr_co_ci);
	PSC_INSERT_CELL(info);
#endif
}

void fulladder::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_a, delay_a, wres_a, wcap_b, delay_b, wres_b, wcap_ci, delay_ci, wres_ci, wcap_s, wcap_co;
	sc_interface *_if_a, *_if_b, *_if_ci, *_if_s, *_if_co;
	psc_objinfo_if *_p_a, *_p_b, *_p_ci, *_p_s, *_p_co;

	_if_a = a.get_interface();
	_p_a = dynamic_cast<psc_objinfo_if*>(_if_a);
	wcap_a = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_a->get_fanout()-1];
	_p_a->set_wire_load(wcap_a);
	wres_a = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_a->get_fanout()-1] * 1e3;
	delay_a = (wres_a/(double)_p_a->get_fanout())*((wcap_a/(double)_p_a->get_fanout()) + capacitance_a);
	_p_a->add_to_net_load(capacitance_a);
	_p_a->set_net_delay(delay_a);

	_if_b = b.get_interface();
	_p_b = dynamic_cast<psc_objinfo_if*>(_if_b);
	wcap_b = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_b->get_fanout()-1];
	_p_b->set_wire_load(wcap_b);
	wres_b = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_b->get_fanout()-1] * 1e3;
	delay_b = (wres_b/(double)_p_b->get_fanout())*((wcap_b/(double)_p_b->get_fanout()) + capacitance_b);
	_p_b->add_to_net_load(capacitance_b);
	_p_b->set_net_delay(delay_b);

	_if_ci = ci.get_interface();
	_p_ci = dynamic_cast<psc_objinfo_if*>(_if_ci);
	wcap_ci = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ci->get_fanout()-1];
	_p_ci->set_wire_load(wcap_ci);
	wres_ci = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ci->get_fanout()-1] * 1e3;
	delay_ci = (wres_ci/(double)_p_ci->get_fanout())*((wcap_ci/(double)_p_ci->get_fanout()) + capacitance_ci);
	_p_ci->add_to_net_load(capacitance_ci);
	_p_ci->set_net_delay(delay_ci);

	_if_s = s.get_interface();
	_p_s = dynamic_cast<psc_objinfo_if*>(_if_s);
	wcap_s = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s->get_fanout()-1];
	_p_s->set_wire_load(wcap_s);

	_if_co = co.get_interface();
	_p_co = dynamic_cast<psc_objinfo_if*>(_if_co);
	wcap_co = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_co->get_fanout()-1];
	_p_co->set_wire_load(wcap_co);
#endif
}
const char * fulladder::celltype = "fulladder";
const double fulladder::leakage_power = 1.13244e-07;
const double fulladder::capacitance_a = 20.975;
const double fulladder::fanout_load_a = 4;
const double fulladder::capacitance_b = 18.556;
const double fulladder::fanout_load_b = 4;
const double fulladder::capacitance_ci = 16.09;
const double fulladder::fanout_load_ci = 4;
const double fulladder::max_capacitance_s = 250;
const double fulladder::max_fanout_s = 50;
const double fulladder::max_capacitance_co = 250;
const double fulladder::max_fanout_co = 50;

const double fulladder::power_s_a[4][4] = {
	{120.64, 115.94, 115.8, 166.96},
	{113.37, 107.58, 104.48, 148.29},
	{110.95, 105.09, 101.09, 133.76},
	{107.72, 101.86, 97.585, 120.97}
};
const double fulladder::lin_s_a[4] = {0, 20, 50, 250};
const double fulladder::col_s_a[4] = {0, 62.88, 135.11, 625.42};

const double fulladder::power_s_b[4][4] = {
	{120.64, 115.94, 115.8, 166.96},
	{113.37, 107.58, 104.48, 148.29},
	{110.95, 105.09, 101.09, 133.76},
	{107.72, 101.86, 97.585, 120.97}
};
const double fulladder::lin_s_b[4] = {0, 20, 50, 250};
const double fulladder::col_s_b[4] = {0, 62.88, 135.11, 625.42};

const double fulladder::power_s_ci[4][4] = {
	{120.64, 115.94, 115.8, 166.96},
	{113.37, 107.58, 104.48, 148.29},
	{110.95, 105.09, 101.09, 133.76},
	{107.72, 101.86, 97.585, 120.97}
};
const double fulladder::lin_s_ci[4] = {0, 20, 50, 250};
const double fulladder::col_s_ci[4] = {0, 62.88, 135.11, 625.42};

const double fulladder::power_co_a[4][4] = {
	{202.89, 194.53, 204.54, 321},
	{200.47, 195.62, 214.59, 340.06},
	{199.38, 194.97, 216.36, 376.98},
	{197.06, 192.91, 214.68, 402.56}
};
const double fulladder::lin_co_a[4] = {0, 20, 50, 250};
const double fulladder::col_co_a[4] = {0, 62.88, 135.11, 625.42};

const double fulladder::power_co_b[4][4] = {
	{202.89, 194.53, 204.54, 321},
	{200.47, 195.62, 214.59, 340.06},
	{199.38, 194.97, 216.36, 376.98},
	{197.06, 192.91, 214.68, 402.56}
};
const double fulladder::lin_co_b[4] = {0, 20, 50, 250};
const double fulladder::col_co_b[4] = {0, 62.88, 135.11, 625.42};

const double fulladder::power_co_ci[4][4] = {
	{202.89, 194.53, 204.54, 321},
	{200.47, 195.62, 214.59, 340.06},
	{199.38, 194.97, 216.36, 376.98},
	{197.06, 192.91, 214.68, 402.56}
};
const double fulladder::lin_co_ci[4] = {0, 20, 50, 250};
const double fulladder::col_co_ci[4] = {0, 62.88, 135.11, 625.42};

// MODULE: jkrp_2
// PROCESS NAME: proc
void jkrp_2::proc()
{
	q.write(
		IQ.read() 
	);
	qb.write(
		IQN.read() 
	);
}

// MODULE: jkrp_2
// PROCESS NAME: ff_input
void jkrp_2::ff_input()
{
	bool _next_ = ( j.read() & k.read() & ! IQ.read() ) | ( ! j.read() & ! k.read() & IQ.read() ) | ( j.read() & k.read() & ! IQ.read() ) ;

	IQ.write(_next_);
	IQN.write(!_next_);

	if ( rb.read() == 0 ) {
		IQ.write(0);
		IQN.write(1);
	}
}

jkrp_2::~jkrp_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ck = ck.get_interface();
	psc_objinfo_if *_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);

	sc_interface *_if_j = j.get_interface();
	psc_objinfo_if *_p_j = dynamic_cast<psc_objinfo_if*>(_if_j);

	sc_interface *_if_k = k.get_interface();
	psc_objinfo_if *_p_k = dynamic_cast<psc_objinfo_if*>(_if_k);

	sc_interface *_if_rb = rb.get_interface();
	psc_objinfo_if *_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);

	sc_interface *_if_q = q.get_interface();
	psc_objinfo_if *_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);

	sc_interface *_if_qb = qb.get_interface();
	psc_objinfo_if *_p_qb = dynamic_cast<psc_objinfo_if*>(_if_qb);

	int i, j;
	bool p_set;

	psc_point_t pts_ck_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_fall[j]) {
			pts_ck_fall[0].x = col_ck_fall[j-1];
			pts_ck_fall[0].y = power_ck_fall[j-1];

			pts_ck_fall[1].x = col_ck_fall[j];
			pts_ck_fall[1].y = power_ck_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_fall = psc_weighted_average(pts_ck_fall, _p_ck->get_net_delay());

	psc_point_t pts_ck_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ck->get_net_delay() < col_ck_rise[j]) {
			pts_ck_rise[0].x = col_ck_rise[j-1];
			pts_ck_rise[0].y = power_ck_rise[j-1];

			pts_ck_rise[1].x = col_ck_rise[j];
			pts_ck_rise[1].y = power_ck_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ck_rise = psc_weighted_average(pts_ck_rise, _p_ck->get_net_delay());

	psc_point_t pts_j_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_j->get_net_delay() < col_j_fall[j]) {
			pts_j_fall[0].x = col_j_fall[j-1];
			pts_j_fall[0].y = power_j_fall[j-1];

			pts_j_fall[1].x = col_j_fall[j];
			pts_j_fall[1].y = power_j_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_j_fall = psc_weighted_average(pts_j_fall, _p_j->get_net_delay());

	psc_point_t pts_j_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_j->get_net_delay() < col_j_rise[j]) {
			pts_j_rise[0].x = col_j_rise[j-1];
			pts_j_rise[0].y = power_j_rise[j-1];

			pts_j_rise[1].x = col_j_rise[j];
			pts_j_rise[1].y = power_j_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_j_rise = psc_weighted_average(pts_j_rise, _p_j->get_net_delay());

	psc_point_t pts_k_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_k->get_net_delay() < col_k_fall[j]) {
			pts_k_fall[0].x = col_k_fall[j-1];
			pts_k_fall[0].y = power_k_fall[j-1];

			pts_k_fall[1].x = col_k_fall[j];
			pts_k_fall[1].y = power_k_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_k_fall = psc_weighted_average(pts_k_fall, _p_k->get_net_delay());

	psc_point_t pts_k_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_k->get_net_delay() < col_k_rise[j]) {
			pts_k_rise[0].x = col_k_rise[j-1];
			pts_k_rise[0].y = power_k_rise[j-1];

			pts_k_rise[1].x = col_k_rise[j];
			pts_k_rise[1].y = power_k_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_k_rise = psc_weighted_average(pts_k_rise, _p_k->get_net_delay());

	psc_point_t pts_rb_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_fall[j]) {
			pts_rb_fall[0].x = col_rb_fall[j-1];
			pts_rb_fall[0].y = power_rb_fall[j-1];

			pts_rb_fall[1].x = col_rb_fall[j];
			pts_rb_fall[1].y = power_rb_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_fall = psc_weighted_average(pts_rb_fall, _p_rb->get_net_delay());

	psc_point_t pts_rb_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_rb->get_net_delay() < col_rb_rise[j]) {
			pts_rb_rise[0].x = col_rb_rise[j-1];
			pts_rb_rise[0].y = power_rb_rise[j-1];

			pts_rb_rise[1].x = col_rb_rise[j];
			pts_rb_rise[1].y = power_rb_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_rb_rise = psc_weighted_average(pts_rb_rise, _p_rb->get_net_delay());

	psc_point_t pts_q_ck_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_fall[j]) {
					pts_q_ck_fall[0].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[0].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[0].z = power_q_ck_fall[i-1][j-1];

					pts_q_ck_fall[1].y = col_q_ck_fall[j];
					pts_q_ck_fall[1].x = lin_q_ck_fall[i-1];
					pts_q_ck_fall[1].z = power_q_ck_fall[i-1][j];

					pts_q_ck_fall[2].y = col_q_ck_fall[j];
					pts_q_ck_fall[2].x = lin_q_ck_fall[i];
					pts_q_ck_fall[2].z = power_q_ck_fall[i][j];

					pts_q_ck_fall[3].y = col_q_ck_fall[j-1];
					pts_q_ck_fall[3].x = lin_q_ck_fall[i];
					pts_q_ck_fall[3].z = power_q_ck_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_fall = psc_geometric_centroid(pts_q_ck_fall, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_ck_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_ck_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ck->get_net_delay() < col_q_ck_rise[j]) {
					pts_q_ck_rise[0].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[0].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[0].z = power_q_ck_rise[i-1][j-1];

					pts_q_ck_rise[1].y = col_q_ck_rise[j];
					pts_q_ck_rise[1].x = lin_q_ck_rise[i-1];
					pts_q_ck_rise[1].z = power_q_ck_rise[i-1][j];

					pts_q_ck_rise[2].y = col_q_ck_rise[j];
					pts_q_ck_rise[2].x = lin_q_ck_rise[i];
					pts_q_ck_rise[2].z = power_q_ck_rise[i][j];

					pts_q_ck_rise[3].y = col_q_ck_rise[j-1];
					pts_q_ck_rise[3].x = lin_q_ck_rise[i];
					pts_q_ck_rise[3].z = power_q_ck_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_ck_rise = psc_geometric_centroid(pts_q_ck_rise, _p_q->get_net_load(), _p_ck->get_net_delay());

	psc_point_t pts_q_rb_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_fall[j]) {
					pts_q_rb_fall[0].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[0].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[0].z = power_q_rb_fall[i-1][j-1];

					pts_q_rb_fall[1].y = col_q_rb_fall[j];
					pts_q_rb_fall[1].x = lin_q_rb_fall[i-1];
					pts_q_rb_fall[1].z = power_q_rb_fall[i-1][j];

					pts_q_rb_fall[2].y = col_q_rb_fall[j];
					pts_q_rb_fall[2].x = lin_q_rb_fall[i];
					pts_q_rb_fall[2].z = power_q_rb_fall[i][j];

					pts_q_rb_fall[3].y = col_q_rb_fall[j-1];
					pts_q_rb_fall[3].x = lin_q_rb_fall[i];
					pts_q_rb_fall[3].z = power_q_rb_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_fall = psc_geometric_centroid(pts_q_rb_fall, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_point_t pts_q_rb_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_q->get_net_load() < lin_q_rb_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_rb->get_net_delay() < col_q_rb_rise[j]) {
					pts_q_rb_rise[0].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[0].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[0].z = power_q_rb_rise[i-1][j-1];

					pts_q_rb_rise[1].y = col_q_rb_rise[j];
					pts_q_rb_rise[1].x = lin_q_rb_rise[i-1];
					pts_q_rb_rise[1].z = power_q_rb_rise[i-1][j];

					pts_q_rb_rise[2].y = col_q_rb_rise[j];
					pts_q_rb_rise[2].x = lin_q_rb_rise[i];
					pts_q_rb_rise[2].z = power_q_rb_rise[i][j];

					pts_q_rb_rise[3].y = col_q_rb_rise[j-1];
					pts_q_rb_rise[3].x = lin_q_rb_rise[i];
					pts_q_rb_rise[3].z = power_q_rb_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_q_rb_rise = psc_geometric_centroid(pts_q_rb_rise, _p_q->get_net_load(), _p_rb->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ck_fall(_p_ck->get_id(), E_ck_fall);
	pwr_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_fall);
	psc_pin_power_info pwr_ck_rise(_p_ck->get_id(), E_ck_rise);
	pwr_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_ck_rise);
	psc_pin_power_info pwr_j_fall(_p_j->get_id(), E_j_fall);
	pwr_j_fall.set_rel_pins(1, _p_j->get_id().c_str());
	info.add(pwr_j_fall);
	psc_pin_power_info pwr_j_rise(_p_j->get_id(), E_j_rise);
	pwr_j_rise.set_rel_pins(1, _p_j->get_id().c_str());
	info.add(pwr_j_rise);
	psc_pin_power_info pwr_k_fall(_p_k->get_id(), E_k_fall);
	pwr_k_fall.set_rel_pins(1, _p_k->get_id().c_str());
	info.add(pwr_k_fall);
	psc_pin_power_info pwr_k_rise(_p_k->get_id(), E_k_rise);
	pwr_k_rise.set_rel_pins(1, _p_k->get_id().c_str());
	info.add(pwr_k_rise);
	psc_pin_power_info pwr_rb_fall(_p_rb->get_id(), E_rb_fall);
	pwr_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_fall);
	psc_pin_power_info pwr_rb_rise(_p_rb->get_id(), E_rb_rise);
	pwr_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_rb_rise);
	psc_pin_power_info pwr_q_ck_fall(_p_q->get_id(), E_q_ck_fall);
	pwr_q_ck_fall.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_fall);
	psc_pin_power_info pwr_q_ck_rise(_p_q->get_id(), E_q_ck_rise);
	pwr_q_ck_rise.set_rel_pins(1, _p_ck->get_id().c_str());
	info.add(pwr_q_ck_rise);
	psc_pin_power_info pwr_q_rb_fall(_p_q->get_id(), E_q_rb_fall);
	pwr_q_rb_fall.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_fall);
	psc_pin_power_info pwr_q_rb_rise(_p_q->get_id(), E_q_rb_rise);
	pwr_q_rb_rise.set_rel_pins(1, _p_rb->get_id().c_str());
	info.add(pwr_q_rb_rise);
	PSC_INSERT_CELL(info);
#endif
}

void jkrp_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ck, delay_ck, wres_ck, wcap_j, delay_j, wres_j, wcap_k, delay_k, wres_k, wcap_rb, delay_rb, wres_rb, wcap_q, wcap_qb;
	sc_interface *_if_ck, *_if_j, *_if_k, *_if_rb, *_if_q, *_if_qb;
	psc_objinfo_if *_p_ck, *_p_j, *_p_k, *_p_rb, *_p_q, *_p_qb;

	_if_ck = ck.get_interface();
	_p_ck = dynamic_cast<psc_objinfo_if*>(_if_ck);
	wcap_ck = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1];
	_p_ck->set_wire_load(wcap_ck);
	wres_ck = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ck->get_fanout()-1] * 1e3;
	delay_ck = (wres_ck/(double)_p_ck->get_fanout())*((wcap_ck/(double)_p_ck->get_fanout()) + capacitance_ck);
	_p_ck->add_to_net_load(capacitance_ck);
	_p_ck->set_net_delay(delay_ck);

	_if_j = j.get_interface();
	_p_j = dynamic_cast<psc_objinfo_if*>(_if_j);
	wcap_j = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_j->get_fanout()-1];
	_p_j->set_wire_load(wcap_j);
	wres_j = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_j->get_fanout()-1] * 1e3;
	delay_j = (wres_j/(double)_p_j->get_fanout())*((wcap_j/(double)_p_j->get_fanout()) + capacitance_j);
	_p_j->add_to_net_load(capacitance_j);
	_p_j->set_net_delay(delay_j);

	_if_k = k.get_interface();
	_p_k = dynamic_cast<psc_objinfo_if*>(_if_k);
	wcap_k = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_k->get_fanout()-1];
	_p_k->set_wire_load(wcap_k);
	wres_k = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_k->get_fanout()-1] * 1e3;
	delay_k = (wres_k/(double)_p_k->get_fanout())*((wcap_k/(double)_p_k->get_fanout()) + capacitance_k);
	_p_k->add_to_net_load(capacitance_k);
	_p_k->set_net_delay(delay_k);

	_if_rb = rb.get_interface();
	_p_rb = dynamic_cast<psc_objinfo_if*>(_if_rb);
	wcap_rb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1];
	_p_rb->set_wire_load(wcap_rb);
	wres_rb = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_rb->get_fanout()-1] * 1e3;
	delay_rb = (wres_rb/(double)_p_rb->get_fanout())*((wcap_rb/(double)_p_rb->get_fanout()) + capacitance_rb);
	_p_rb->add_to_net_load(capacitance_rb);
	_p_rb->set_net_delay(delay_rb);

	_if_q = q.get_interface();
	_p_q = dynamic_cast<psc_objinfo_if*>(_if_q);
	wcap_q = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_q->get_fanout()-1];
	_p_q->set_wire_load(wcap_q);

	_if_qb = qb.get_interface();
	_p_qb = dynamic_cast<psc_objinfo_if*>(_if_qb);
	wcap_qb = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_qb->get_fanout()-1];
	_p_qb->set_wire_load(wcap_qb);
#endif
}
const char * jkrp_2::celltype = "jkrp_2";
const double jkrp_2::leakage_power = 1.13758e-06;
const double jkrp_2::capacitance_ck = 5.2775;
const double jkrp_2::fanout_load_ck = 2;
const double jkrp_2::capacitance_j = 4.8455;
const double jkrp_2::fanout_load_j = 1;
const double jkrp_2::capacitance_k = 3.768;
const double jkrp_2::fanout_load_k = 1;
const double jkrp_2::capacitance_rb = 9.3903;
const double jkrp_2::fanout_load_rb = 2;
const double jkrp_2::max_capacitance_q = 250;
const double jkrp_2::max_fanout_q = 50;
const double jkrp_2::max_capacitance_qb = 250;
const double jkrp_2::max_fanout_qb = 50;

const double jkrp_2::power_ck_fall[4] = {
	240.54, 240.54, 240.54, 240.54
};
const double jkrp_2::col_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_ck_rise[4] = {
	136.2, 136.2, 136.2, 136.2
};
const double jkrp_2::col_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double jkrp_2::power_j_fall[4] = {
	59.985, 59.987, 59.988, 59.987
};
const double jkrp_2::col_j_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_j_rise[4] = {
	73.166, 73.166, 73.166, 73.165
};
const double jkrp_2::col_j_rise[4] = {0, 66.037, 144.95, 672.54};

const double jkrp_2::power_k_fall[4] = {
	0.43254, 0.43255, 0.43255, 0.43255
};
const double jkrp_2::col_k_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_k_rise[4] = {
	73.146, 73.146, 73.146, 73.146
};
const double jkrp_2::col_k_rise[4] = {0, 66.037, 144.95, 672.54};

const double jkrp_2::power_rb_fall[4] = {
	180.76, 207.12, 251.38, 560.61
};
const double jkrp_2::col_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_rb_rise[4] = {
	58.037, 58.045, 58.081, 58.089
};
const double jkrp_2::col_rb_rise[4] = {0, 66.037, 144.95, 672.54};

const double jkrp_2::power_q_ck_fall[4][4] = {
	{431.9, 418.48, 424.88, 425.46},
	{418.48, 432.64, 418.26, 419.24},
	{414.4, 426.48, 416.97, 417.77},
	{410.42, 425.06, 415.35, 416.03}
};
const double jkrp_2::lin_q_ck_fall[4] = {0, 20, 50, 250};
const double jkrp_2::col_q_ck_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_q_ck_rise[4][4] = {
	{462.06, 442.98, 451.63, 453.16},
	{442.98, 458.03, 442.76, 444.17},
	{434.9, 449.06, 437.36, 438.92},
	{425.52, 443.79, 430.9, 432.37}
};
const double jkrp_2::lin_q_ck_rise[4] = {0, 20, 50, 250};
const double jkrp_2::col_q_ck_rise[4] = {0, 66.037, 144.95, 672.54};

const double jkrp_2::power_q_rb_fall[4][4] = {
	{431.9, 418.48, 424.88, 425.46},
	{418.48, 432.64, 418.26, 419.24},
	{414.4, 426.48, 416.97, 417.77},
	{410.42, 425.06, 415.35, 416.03}
};
const double jkrp_2::lin_q_rb_fall[4] = {0, 20, 50, 250};
const double jkrp_2::col_q_rb_fall[4] = {0, 59.722, 125.27, 578.29};

const double jkrp_2::power_q_rb_rise[4][4] = {
	{462.06, 442.98, 451.63, 453.16},
	{442.98, 458.03, 442.76, 444.17},
	{434.9, 449.06, 437.36, 438.92},
	{425.52, 443.79, 430.9, 432.37}
};
const double jkrp_2::lin_q_rb_rise[4] = {0, 20, 50, 250};
const double jkrp_2::col_q_rb_rise[4] = {0, 66.037, 144.95, 672.54};

// MODULE: mux3_2
// PROCESS NAME: proc
void mux3_2::proc()
{
	op.write(
		( ( ! s1.read() & ! s0.read() & ip1.read() ) | ( ! s1.read() & s0.read() & ip2.read() ) | ( s1.read() & ip3.read() ) ) 
	);
}

mux3_2::~mux3_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_s0 = s0.get_interface();
	psc_objinfo_if *_p_s0 = dynamic_cast<psc_objinfo_if*>(_if_s0);

	sc_interface *_if_s1 = s1.get_interface();
	psc_objinfo_if *_p_s1 = dynamic_cast<psc_objinfo_if*>(_if_s1);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_ip1_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip1->get_net_delay() < col_ip1_fall[j]) {
			pts_ip1_fall[0].x = col_ip1_fall[j-1];
			pts_ip1_fall[0].y = power_ip1_fall[j-1];

			pts_ip1_fall[1].x = col_ip1_fall[j];
			pts_ip1_fall[1].y = power_ip1_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip1_fall = psc_weighted_average(pts_ip1_fall, _p_ip1->get_net_delay());

	psc_point_t pts_ip1_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip1->get_net_delay() < col_ip1_rise[j]) {
			pts_ip1_rise[0].x = col_ip1_rise[j-1];
			pts_ip1_rise[0].y = power_ip1_rise[j-1];

			pts_ip1_rise[1].x = col_ip1_rise[j];
			pts_ip1_rise[1].y = power_ip1_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip1_rise = psc_weighted_average(pts_ip1_rise, _p_ip1->get_net_delay());

	psc_point_t pts_ip2_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip2->get_net_delay() < col_ip2_fall[j]) {
			pts_ip2_fall[0].x = col_ip2_fall[j-1];
			pts_ip2_fall[0].y = power_ip2_fall[j-1];

			pts_ip2_fall[1].x = col_ip2_fall[j];
			pts_ip2_fall[1].y = power_ip2_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip2_fall = psc_weighted_average(pts_ip2_fall, _p_ip2->get_net_delay());

	psc_point_t pts_ip2_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip2->get_net_delay() < col_ip2_rise[j]) {
			pts_ip2_rise[0].x = col_ip2_rise[j-1];
			pts_ip2_rise[0].y = power_ip2_rise[j-1];

			pts_ip2_rise[1].x = col_ip2_rise[j];
			pts_ip2_rise[1].y = power_ip2_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip2_rise = psc_weighted_average(pts_ip2_rise, _p_ip2->get_net_delay());

	psc_point_t pts_ip3_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip3->get_net_delay() < col_ip3_fall[j]) {
			pts_ip3_fall[0].x = col_ip3_fall[j-1];
			pts_ip3_fall[0].y = power_ip3_fall[j-1];

			pts_ip3_fall[1].x = col_ip3_fall[j];
			pts_ip3_fall[1].y = power_ip3_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip3_fall = psc_weighted_average(pts_ip3_fall, _p_ip3->get_net_delay());

	psc_point_t pts_ip3_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip3->get_net_delay() < col_ip3_rise[j]) {
			pts_ip3_rise[0].x = col_ip3_rise[j-1];
			pts_ip3_rise[0].y = power_ip3_rise[j-1];

			pts_ip3_rise[1].x = col_ip3_rise[j];
			pts_ip3_rise[1].y = power_ip3_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip3_rise = psc_weighted_average(pts_ip3_rise, _p_ip3->get_net_delay());

	psc_point_t pts_s0_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s0->get_net_delay() < col_s0_fall[j]) {
			pts_s0_fall[0].x = col_s0_fall[j-1];
			pts_s0_fall[0].y = power_s0_fall[j-1];

			pts_s0_fall[1].x = col_s0_fall[j];
			pts_s0_fall[1].y = power_s0_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s0_fall = psc_weighted_average(pts_s0_fall, _p_s0->get_net_delay());

	psc_point_t pts_s0_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s0->get_net_delay() < col_s0_rise[j]) {
			pts_s0_rise[0].x = col_s0_rise[j-1];
			pts_s0_rise[0].y = power_s0_rise[j-1];

			pts_s0_rise[1].x = col_s0_rise[j];
			pts_s0_rise[1].y = power_s0_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s0_rise = psc_weighted_average(pts_s0_rise, _p_s0->get_net_delay());

	psc_point_t pts_s1_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s1->get_net_delay() < col_s1_fall[j]) {
			pts_s1_fall[0].x = col_s1_fall[j-1];
			pts_s1_fall[0].y = power_s1_fall[j-1];

			pts_s1_fall[1].x = col_s1_fall[j];
			pts_s1_fall[1].y = power_s1_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s1_fall = psc_weighted_average(pts_s1_fall, _p_s1->get_net_delay());

	psc_point_t pts_s1_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s1->get_net_delay() < col_s1_rise[j]) {
			pts_s1_rise[0].x = col_s1_rise[j-1];
			pts_s1_rise[0].y = power_s1_rise[j-1];

			pts_s1_rise[1].x = col_s1_rise[j];
			pts_s1_rise[1].y = power_s1_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s1_rise = psc_weighted_average(pts_s1_rise, _p_s1->get_net_delay());

	psc_point_t pts_op_s1[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s1[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s1->get_net_delay() < col_op_s1[j]) {
					pts_op_s1[0].y = col_op_s1[j-1];
					pts_op_s1[0].x = lin_op_s1[i-1];
					pts_op_s1[0].z = power_op_s1[i-1][j-1];

					pts_op_s1[1].y = col_op_s1[j];
					pts_op_s1[1].x = lin_op_s1[i-1];
					pts_op_s1[1].z = power_op_s1[i-1][j];

					pts_op_s1[2].y = col_op_s1[j];
					pts_op_s1[2].x = lin_op_s1[i];
					pts_op_s1[2].z = power_op_s1[i][j];

					pts_op_s1[3].y = col_op_s1[j-1];
					pts_op_s1[3].x = lin_op_s1[i];
					pts_op_s1[3].z = power_op_s1[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s1 = psc_geometric_centroid(pts_op_s1, _p_op->get_net_load(), _p_s1->get_net_delay());

	psc_point_t pts_op_s0[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s0[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s0->get_net_delay() < col_op_s0[j]) {
					pts_op_s0[0].y = col_op_s0[j-1];
					pts_op_s0[0].x = lin_op_s0[i-1];
					pts_op_s0[0].z = power_op_s0[i-1][j-1];

					pts_op_s0[1].y = col_op_s0[j];
					pts_op_s0[1].x = lin_op_s0[i-1];
					pts_op_s0[1].z = power_op_s0[i-1][j];

					pts_op_s0[2].y = col_op_s0[j];
					pts_op_s0[2].x = lin_op_s0[i];
					pts_op_s0[2].z = power_op_s0[i][j];

					pts_op_s0[3].y = col_op_s0[j-1];
					pts_op_s0[3].x = lin_op_s0[i];
					pts_op_s0[3].z = power_op_s0[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s0 = psc_geometric_centroid(pts_op_s0, _p_op->get_net_load(), _p_s0->get_net_delay());

	psc_point_t pts_op_ip1[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1[j]) {
					pts_op_ip1[0].y = col_op_ip1[j-1];
					pts_op_ip1[0].x = lin_op_ip1[i-1];
					pts_op_ip1[0].z = power_op_ip1[i-1][j-1];

					pts_op_ip1[1].y = col_op_ip1[j];
					pts_op_ip1[1].x = lin_op_ip1[i-1];
					pts_op_ip1[1].z = power_op_ip1[i-1][j];

					pts_op_ip1[2].y = col_op_ip1[j];
					pts_op_ip1[2].x = lin_op_ip1[i];
					pts_op_ip1[2].z = power_op_ip1[i][j];

					pts_op_ip1[3].y = col_op_ip1[j-1];
					pts_op_ip1[3].x = lin_op_ip1[i];
					pts_op_ip1[3].z = power_op_ip1[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1 = psc_geometric_centroid(pts_op_ip1, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2[j]) {
					pts_op_ip2[0].y = col_op_ip2[j-1];
					pts_op_ip2[0].x = lin_op_ip2[i-1];
					pts_op_ip2[0].z = power_op_ip2[i-1][j-1];

					pts_op_ip2[1].y = col_op_ip2[j];
					pts_op_ip2[1].x = lin_op_ip2[i-1];
					pts_op_ip2[1].z = power_op_ip2[i-1][j];

					pts_op_ip2[2].y = col_op_ip2[j];
					pts_op_ip2[2].x = lin_op_ip2[i];
					pts_op_ip2[2].z = power_op_ip2[i][j];

					pts_op_ip2[3].y = col_op_ip2[j-1];
					pts_op_ip2[3].x = lin_op_ip2[i];
					pts_op_ip2[3].z = power_op_ip2[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2 = psc_geometric_centroid(pts_op_ip2, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3[j]) {
					pts_op_ip3[0].y = col_op_ip3[j-1];
					pts_op_ip3[0].x = lin_op_ip3[i-1];
					pts_op_ip3[0].z = power_op_ip3[i-1][j-1];

					pts_op_ip3[1].y = col_op_ip3[j];
					pts_op_ip3[1].x = lin_op_ip3[i-1];
					pts_op_ip3[1].z = power_op_ip3[i-1][j];

					pts_op_ip3[2].y = col_op_ip3[j];
					pts_op_ip3[2].x = lin_op_ip3[i];
					pts_op_ip3[2].z = power_op_ip3[i][j];

					pts_op_ip3[3].y = col_op_ip3[j-1];
					pts_op_ip3[3].x = lin_op_ip3[i];
					pts_op_ip3[3].z = power_op_ip3[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3 = psc_geometric_centroid(pts_op_ip3, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ip1_fall(_p_ip1->get_id(), E_ip1_fall);
	pwr_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_ip1_fall);
	psc_pin_power_info pwr_ip1_rise(_p_ip1->get_id(), E_ip1_rise);
	pwr_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_ip1_rise);
	psc_pin_power_info pwr_ip2_fall(_p_ip2->get_id(), E_ip2_fall);
	pwr_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_ip2_fall);
	psc_pin_power_info pwr_ip2_rise(_p_ip2->get_id(), E_ip2_rise);
	pwr_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_ip2_rise);
	psc_pin_power_info pwr_ip3_fall(_p_ip3->get_id(), E_ip3_fall);
	pwr_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_ip3_fall);
	psc_pin_power_info pwr_ip3_rise(_p_ip3->get_id(), E_ip3_rise);
	pwr_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_ip3_rise);
	psc_pin_power_info pwr_s0_fall(_p_s0->get_id(), E_s0_fall);
	pwr_s0_fall.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_s0_fall);
	psc_pin_power_info pwr_s0_rise(_p_s0->get_id(), E_s0_rise);
	pwr_s0_rise.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_s0_rise);
	psc_pin_power_info pwr_s1_fall(_p_s1->get_id(), E_s1_fall);
	pwr_s1_fall.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_s1_fall);
	psc_pin_power_info pwr_s1_rise(_p_s1->get_id(), E_s1_rise);
	pwr_s1_rise.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_s1_rise);
	psc_pin_power_info pwr_op_s1(_p_op->get_id(), E_op_s1);
	pwr_op_s1.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_op_s1);
	psc_pin_power_info pwr_op_s0(_p_op->get_id(), E_op_s0);
	pwr_op_s0.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_op_s0);
	psc_pin_power_info pwr_op_ip1(_p_op->get_id(), E_op_ip1);
	pwr_op_ip1.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1);
	psc_pin_power_info pwr_op_ip2(_p_op->get_id(), E_op_ip2);
	pwr_op_ip2.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2);
	psc_pin_power_info pwr_op_ip3(_p_op->get_id(), E_op_ip3);
	pwr_op_ip3.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3);
	PSC_INSERT_CELL(info);
#endif
}

void mux3_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_s0, delay_s0, wres_s0, wcap_s1, delay_s1, wres_s1, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_s0, *_if_s1, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_s0, *_p_s1, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_s0 = s0.get_interface();
	_p_s0 = dynamic_cast<psc_objinfo_if*>(_if_s0);
	wcap_s0 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s0->get_fanout()-1];
	_p_s0->set_wire_load(wcap_s0);
	wres_s0 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s0->get_fanout()-1] * 1e3;
	delay_s0 = (wres_s0/(double)_p_s0->get_fanout())*((wcap_s0/(double)_p_s0->get_fanout()) + capacitance_s0);
	_p_s0->add_to_net_load(capacitance_s0);
	_p_s0->set_net_delay(delay_s0);

	_if_s1 = s1.get_interface();
	_p_s1 = dynamic_cast<psc_objinfo_if*>(_if_s1);
	wcap_s1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s1->get_fanout()-1];
	_p_s1->set_wire_load(wcap_s1);
	wres_s1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s1->get_fanout()-1] * 1e3;
	delay_s1 = (wres_s1/(double)_p_s1->get_fanout())*((wcap_s1/(double)_p_s1->get_fanout()) + capacitance_s1);
	_p_s1->add_to_net_load(capacitance_s1);
	_p_s1->set_net_delay(delay_s1);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * mux3_2::celltype = "mux3_2";
const double mux3_2::leakage_power = 3.2173e-07;
const double mux3_2::capacitance_ip1 = 9.6654;
const double mux3_2::fanout_load_ip1 = 2;
const double mux3_2::capacitance_ip2 = 9.7528;
const double mux3_2::fanout_load_ip2 = 2;
const double mux3_2::capacitance_ip3 = 9.806;
const double mux3_2::fanout_load_ip3 = 2;
const double mux3_2::capacitance_s0 = 14.699;
const double mux3_2::fanout_load_s0 = 3;
const double mux3_2::capacitance_s1 = 14.662;
const double mux3_2::fanout_load_s1 = 3;
const double mux3_2::max_capacitance_op = 250;
const double mux3_2::max_fanout_op = 50;

const double mux3_2::power_ip1_fall[4] = {
	112.5, 112.5, 112.5, 112.5
};
const double mux3_2::col_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_ip1_rise[4] = {
	115.61, 115.61, 115.61, 115.61
};
const double mux3_2::col_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_ip2_fall[4] = {
	107.87, 107.87, 107.87, 107.87
};
const double mux3_2::col_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_ip2_rise[4] = {
	111.4, 111.4, 111.4, 111.4
};
const double mux3_2::col_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_ip3_fall[4] = {
	64.898, 64.898, 64.898, 64.898
};
const double mux3_2::col_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_ip3_rise[4] = {
	65.157, 65.157, 65.157, 65.157
};
const double mux3_2::col_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_s0_fall[4] = {
	65.826, 65.826, 65.826, 65.826
};
const double mux3_2::col_s0_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_s0_rise[4] = {
	64.388, 64.36, 64.36, 64.36
};
const double mux3_2::col_s0_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_s1_fall[4] = {
	64.753, 64.752, 64.746, 64.746
};
const double mux3_2::col_s1_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_s1_rise[4] = {
	63.809, 63.809, 63.81, 63.81
};
const double mux3_2::col_s1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux3_2::power_op_s1[4][4] = {
	{127.53, 120.09, 127.8, 132.91},
	{120.09, 181.84, 120.05, 124.17},
	{116.93, 167.17, 116.92, 119.96},
	{113.44, 157.93, 113.16, 115.27}
};
const double mux3_2::lin_op_s1[4] = {0, 20, 50, 250};
const double mux3_2::col_op_s1[4] = {0, 62.88, 135.11, 625.42};

const double mux3_2::power_op_s0[4][4] = {
	{127.53, 120.09, 127.8, 132.91},
	{120.09, 181.84, 120.05, 124.17},
	{116.93, 167.17, 116.92, 119.96},
	{113.44, 157.93, 113.16, 115.27}
};
const double mux3_2::lin_op_s0[4] = {0, 20, 50, 250};
const double mux3_2::col_op_s0[4] = {0, 62.88, 135.11, 625.42};

const double mux3_2::power_op_ip1[4][4] = {
	{127.53, 120.09, 127.8, 132.91},
	{120.09, 181.84, 120.05, 124.17},
	{116.93, 167.17, 116.92, 119.96},
	{113.44, 157.93, 113.16, 115.27}
};
const double mux3_2::lin_op_ip1[4] = {0, 20, 50, 250};
const double mux3_2::col_op_ip1[4] = {0, 62.88, 135.11, 625.42};

const double mux3_2::power_op_ip2[4][4] = {
	{127.53, 120.09, 127.8, 132.91},
	{120.09, 181.84, 120.05, 124.17},
	{116.93, 167.17, 116.92, 119.96},
	{113.44, 157.93, 113.16, 115.27}
};
const double mux3_2::lin_op_ip2[4] = {0, 20, 50, 250};
const double mux3_2::col_op_ip2[4] = {0, 62.88, 135.11, 625.42};

const double mux3_2::power_op_ip3[4][4] = {
	{127.53, 120.09, 127.8, 132.91},
	{120.09, 181.84, 120.05, 124.17},
	{116.93, 167.17, 116.92, 119.96},
	{113.44, 157.93, 113.16, 115.27}
};
const double mux3_2::lin_op_ip3[4] = {0, 20, 50, 250};
const double mux3_2::col_op_ip3[4] = {0, 62.88, 135.11, 625.42};

// MODULE: mux4_2
// PROCESS NAME: proc
void mux4_2::proc()
{
	op.write(
		( ( ! s1.read() & ! s0.read() & ip1.read() ) | ( ! s1.read() & s0.read() & ip2.read() ) | ( s1.read() & ! s0.read() & ip3.read() ) | ( s1.read() & s0.read() & ip4.read() ) ) 
	);
}

mux4_2::~mux4_2()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_s0 = s0.get_interface();
	psc_objinfo_if *_p_s0 = dynamic_cast<psc_objinfo_if*>(_if_s0);

	sc_interface *_if_s1 = s1.get_interface();
	psc_objinfo_if *_p_s1 = dynamic_cast<psc_objinfo_if*>(_if_s1);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_ip1_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip1->get_net_delay() < col_ip1_fall[j]) {
			pts_ip1_fall[0].x = col_ip1_fall[j-1];
			pts_ip1_fall[0].y = power_ip1_fall[j-1];

			pts_ip1_fall[1].x = col_ip1_fall[j];
			pts_ip1_fall[1].y = power_ip1_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip1_fall = psc_weighted_average(pts_ip1_fall, _p_ip1->get_net_delay());

	psc_point_t pts_ip1_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip1->get_net_delay() < col_ip1_rise[j]) {
			pts_ip1_rise[0].x = col_ip1_rise[j-1];
			pts_ip1_rise[0].y = power_ip1_rise[j-1];

			pts_ip1_rise[1].x = col_ip1_rise[j];
			pts_ip1_rise[1].y = power_ip1_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip1_rise = psc_weighted_average(pts_ip1_rise, _p_ip1->get_net_delay());

	psc_point_t pts_ip2_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip2->get_net_delay() < col_ip2_fall[j]) {
			pts_ip2_fall[0].x = col_ip2_fall[j-1];
			pts_ip2_fall[0].y = power_ip2_fall[j-1];

			pts_ip2_fall[1].x = col_ip2_fall[j];
			pts_ip2_fall[1].y = power_ip2_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip2_fall = psc_weighted_average(pts_ip2_fall, _p_ip2->get_net_delay());

	psc_point_t pts_ip2_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip2->get_net_delay() < col_ip2_rise[j]) {
			pts_ip2_rise[0].x = col_ip2_rise[j-1];
			pts_ip2_rise[0].y = power_ip2_rise[j-1];

			pts_ip2_rise[1].x = col_ip2_rise[j];
			pts_ip2_rise[1].y = power_ip2_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip2_rise = psc_weighted_average(pts_ip2_rise, _p_ip2->get_net_delay());

	psc_point_t pts_ip3_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip3->get_net_delay() < col_ip3_fall[j]) {
			pts_ip3_fall[0].x = col_ip3_fall[j-1];
			pts_ip3_fall[0].y = power_ip3_fall[j-1];

			pts_ip3_fall[1].x = col_ip3_fall[j];
			pts_ip3_fall[1].y = power_ip3_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip3_fall = psc_weighted_average(pts_ip3_fall, _p_ip3->get_net_delay());

	psc_point_t pts_ip3_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip3->get_net_delay() < col_ip3_rise[j]) {
			pts_ip3_rise[0].x = col_ip3_rise[j-1];
			pts_ip3_rise[0].y = power_ip3_rise[j-1];

			pts_ip3_rise[1].x = col_ip3_rise[j];
			pts_ip3_rise[1].y = power_ip3_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip3_rise = psc_weighted_average(pts_ip3_rise, _p_ip3->get_net_delay());

	psc_point_t pts_ip4_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip4->get_net_delay() < col_ip4_fall[j]) {
			pts_ip4_fall[0].x = col_ip4_fall[j-1];
			pts_ip4_fall[0].y = power_ip4_fall[j-1];

			pts_ip4_fall[1].x = col_ip4_fall[j];
			pts_ip4_fall[1].y = power_ip4_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip4_fall = psc_weighted_average(pts_ip4_fall, _p_ip4->get_net_delay());

	psc_point_t pts_ip4_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_ip4->get_net_delay() < col_ip4_rise[j]) {
			pts_ip4_rise[0].x = col_ip4_rise[j-1];
			pts_ip4_rise[0].y = power_ip4_rise[j-1];

			pts_ip4_rise[1].x = col_ip4_rise[j];
			pts_ip4_rise[1].y = power_ip4_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_ip4_rise = psc_weighted_average(pts_ip4_rise, _p_ip4->get_net_delay());

	psc_point_t pts_s0_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s0->get_net_delay() < col_s0_fall[j]) {
			pts_s0_fall[0].x = col_s0_fall[j-1];
			pts_s0_fall[0].y = power_s0_fall[j-1];

			pts_s0_fall[1].x = col_s0_fall[j];
			pts_s0_fall[1].y = power_s0_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s0_fall = psc_weighted_average(pts_s0_fall, _p_s0->get_net_delay());

	psc_point_t pts_s0_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s0->get_net_delay() < col_s0_rise[j]) {
			pts_s0_rise[0].x = col_s0_rise[j-1];
			pts_s0_rise[0].y = power_s0_rise[j-1];

			pts_s0_rise[1].x = col_s0_rise[j];
			pts_s0_rise[1].y = power_s0_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s0_rise = psc_weighted_average(pts_s0_rise, _p_s0->get_net_delay());

	psc_point_t pts_s1_fall[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s1->get_net_delay() < col_s1_fall[j]) {
			pts_s1_fall[0].x = col_s1_fall[j-1];
			pts_s1_fall[0].y = power_s1_fall[j-1];

			pts_s1_fall[1].x = col_s1_fall[j];
			pts_s1_fall[1].y = power_s1_fall[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s1_fall = psc_weighted_average(pts_s1_fall, _p_s1->get_net_delay());

	psc_point_t pts_s1_rise[2];
	for (p_set=false, j=1 ; j<4 ; j++)
		if (_p_s1->get_net_delay() < col_s1_rise[j]) {
			pts_s1_rise[0].x = col_s1_rise[j-1];
			pts_s1_rise[0].y = power_s1_rise[j-1];

			pts_s1_rise[1].x = col_s1_rise[j];
			pts_s1_rise[1].y = power_s1_rise[j];

			p_set = true;
			break;
		}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_s1_rise = psc_weighted_average(pts_s1_rise, _p_s1->get_net_delay());

	psc_point_t pts_op_s1[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s1[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s1->get_net_delay() < col_op_s1[j]) {
					pts_op_s1[0].y = col_op_s1[j-1];
					pts_op_s1[0].x = lin_op_s1[i-1];
					pts_op_s1[0].z = power_op_s1[i-1][j-1];

					pts_op_s1[1].y = col_op_s1[j];
					pts_op_s1[1].x = lin_op_s1[i-1];
					pts_op_s1[1].z = power_op_s1[i-1][j];

					pts_op_s1[2].y = col_op_s1[j];
					pts_op_s1[2].x = lin_op_s1[i];
					pts_op_s1[2].z = power_op_s1[i][j];

					pts_op_s1[3].y = col_op_s1[j-1];
					pts_op_s1[3].x = lin_op_s1[i];
					pts_op_s1[3].z = power_op_s1[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s1 = psc_geometric_centroid(pts_op_s1, _p_op->get_net_load(), _p_s1->get_net_delay());

	psc_point_t pts_op_s0[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_s0[i])
			for (j=1 ; j<4 ; j++)
				if (_p_s0->get_net_delay() < col_op_s0[j]) {
					pts_op_s0[0].y = col_op_s0[j-1];
					pts_op_s0[0].x = lin_op_s0[i-1];
					pts_op_s0[0].z = power_op_s0[i-1][j-1];

					pts_op_s0[1].y = col_op_s0[j];
					pts_op_s0[1].x = lin_op_s0[i-1];
					pts_op_s0[1].z = power_op_s0[i-1][j];

					pts_op_s0[2].y = col_op_s0[j];
					pts_op_s0[2].x = lin_op_s0[i];
					pts_op_s0[2].z = power_op_s0[i][j];

					pts_op_s0[3].y = col_op_s0[j-1];
					pts_op_s0[3].x = lin_op_s0[i];
					pts_op_s0[3].z = power_op_s0[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_s0 = psc_geometric_centroid(pts_op_s0, _p_op->get_net_load(), _p_s0->get_net_delay());

	psc_point_t pts_op_ip1[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1[j]) {
					pts_op_ip1[0].y = col_op_ip1[j-1];
					pts_op_ip1[0].x = lin_op_ip1[i-1];
					pts_op_ip1[0].z = power_op_ip1[i-1][j-1];

					pts_op_ip1[1].y = col_op_ip1[j];
					pts_op_ip1[1].x = lin_op_ip1[i-1];
					pts_op_ip1[1].z = power_op_ip1[i-1][j];

					pts_op_ip1[2].y = col_op_ip1[j];
					pts_op_ip1[2].x = lin_op_ip1[i];
					pts_op_ip1[2].z = power_op_ip1[i][j];

					pts_op_ip1[3].y = col_op_ip1[j-1];
					pts_op_ip1[3].x = lin_op_ip1[i];
					pts_op_ip1[3].z = power_op_ip1[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1 = psc_geometric_centroid(pts_op_ip1, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2[j]) {
					pts_op_ip2[0].y = col_op_ip2[j-1];
					pts_op_ip2[0].x = lin_op_ip2[i-1];
					pts_op_ip2[0].z = power_op_ip2[i-1][j-1];

					pts_op_ip2[1].y = col_op_ip2[j];
					pts_op_ip2[1].x = lin_op_ip2[i-1];
					pts_op_ip2[1].z = power_op_ip2[i-1][j];

					pts_op_ip2[2].y = col_op_ip2[j];
					pts_op_ip2[2].x = lin_op_ip2[i];
					pts_op_ip2[2].z = power_op_ip2[i][j];

					pts_op_ip2[3].y = col_op_ip2[j-1];
					pts_op_ip2[3].x = lin_op_ip2[i];
					pts_op_ip2[3].z = power_op_ip2[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2 = psc_geometric_centroid(pts_op_ip2, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3[j]) {
					pts_op_ip3[0].y = col_op_ip3[j-1];
					pts_op_ip3[0].x = lin_op_ip3[i-1];
					pts_op_ip3[0].z = power_op_ip3[i-1][j-1];

					pts_op_ip3[1].y = col_op_ip3[j];
					pts_op_ip3[1].x = lin_op_ip3[i-1];
					pts_op_ip3[1].z = power_op_ip3[i-1][j];

					pts_op_ip3[2].y = col_op_ip3[j];
					pts_op_ip3[2].x = lin_op_ip3[i];
					pts_op_ip3[2].z = power_op_ip3[i][j];

					pts_op_ip3[3].y = col_op_ip3[j-1];
					pts_op_ip3[3].x = lin_op_ip3[i];
					pts_op_ip3[3].z = power_op_ip3[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3 = psc_geometric_centroid(pts_op_ip3, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4[j]) {
					pts_op_ip4[0].y = col_op_ip4[j-1];
					pts_op_ip4[0].x = lin_op_ip4[i-1];
					pts_op_ip4[0].z = power_op_ip4[i-1][j-1];

					pts_op_ip4[1].y = col_op_ip4[j];
					pts_op_ip4[1].x = lin_op_ip4[i-1];
					pts_op_ip4[1].z = power_op_ip4[i-1][j];

					pts_op_ip4[2].y = col_op_ip4[j];
					pts_op_ip4[2].x = lin_op_ip4[i];
					pts_op_ip4[2].z = power_op_ip4[i][j];

					pts_op_ip4[3].y = col_op_ip4[j-1];
					pts_op_ip4[3].x = lin_op_ip4[i];
					pts_op_ip4[3].z = power_op_ip4[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4 = psc_geometric_centroid(pts_op_ip4, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_ip1_fall(_p_ip1->get_id(), E_ip1_fall);
	pwr_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_ip1_fall);
	psc_pin_power_info pwr_ip1_rise(_p_ip1->get_id(), E_ip1_rise);
	pwr_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_ip1_rise);
	psc_pin_power_info pwr_ip2_fall(_p_ip2->get_id(), E_ip2_fall);
	pwr_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_ip2_fall);
	psc_pin_power_info pwr_ip2_rise(_p_ip2->get_id(), E_ip2_rise);
	pwr_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_ip2_rise);
	psc_pin_power_info pwr_ip3_fall(_p_ip3->get_id(), E_ip3_fall);
	pwr_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_ip3_fall);
	psc_pin_power_info pwr_ip3_rise(_p_ip3->get_id(), E_ip3_rise);
	pwr_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_ip3_rise);
	psc_pin_power_info pwr_ip4_fall(_p_ip4->get_id(), E_ip4_fall);
	pwr_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_ip4_fall);
	psc_pin_power_info pwr_ip4_rise(_p_ip4->get_id(), E_ip4_rise);
	pwr_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_ip4_rise);
	psc_pin_power_info pwr_s0_fall(_p_s0->get_id(), E_s0_fall);
	pwr_s0_fall.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_s0_fall);
	psc_pin_power_info pwr_s0_rise(_p_s0->get_id(), E_s0_rise);
	pwr_s0_rise.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_s0_rise);
	psc_pin_power_info pwr_s1_fall(_p_s1->get_id(), E_s1_fall);
	pwr_s1_fall.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_s1_fall);
	psc_pin_power_info pwr_s1_rise(_p_s1->get_id(), E_s1_rise);
	pwr_s1_rise.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_s1_rise);
	psc_pin_power_info pwr_op_s1(_p_op->get_id(), E_op_s1);
	pwr_op_s1.set_rel_pins(1, _p_s1->get_id().c_str());
	info.add(pwr_op_s1);
	psc_pin_power_info pwr_op_s0(_p_op->get_id(), E_op_s0);
	pwr_op_s0.set_rel_pins(1, _p_s0->get_id().c_str());
	info.add(pwr_op_s0);
	psc_pin_power_info pwr_op_ip1(_p_op->get_id(), E_op_ip1);
	pwr_op_ip1.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1);
	psc_pin_power_info pwr_op_ip2(_p_op->get_id(), E_op_ip2);
	pwr_op_ip2.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2);
	psc_pin_power_info pwr_op_ip3(_p_op->get_id(), E_op_ip3);
	pwr_op_ip3.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3);
	psc_pin_power_info pwr_op_ip4(_p_op->get_id(), E_op_ip4);
	pwr_op_ip4.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4);
	PSC_INSERT_CELL(info);
#endif
}

void mux4_2::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_s0, delay_s0, wres_s0, wcap_s1, delay_s1, wres_s1, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_s0, *_if_s1, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_s0, *_p_s1, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_s0 = s0.get_interface();
	_p_s0 = dynamic_cast<psc_objinfo_if*>(_if_s0);
	wcap_s0 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s0->get_fanout()-1];
	_p_s0->set_wire_load(wcap_s0);
	wres_s0 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s0->get_fanout()-1] * 1e3;
	delay_s0 = (wres_s0/(double)_p_s0->get_fanout())*((wcap_s0/(double)_p_s0->get_fanout()) + capacitance_s0);
	_p_s0->add_to_net_load(capacitance_s0);
	_p_s0->set_net_delay(delay_s0);

	_if_s1 = s1.get_interface();
	_p_s1 = dynamic_cast<psc_objinfo_if*>(_if_s1);
	wcap_s1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_s1->get_fanout()-1];
	_p_s1->set_wire_load(wcap_s1);
	wres_s1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_s1->get_fanout()-1] * 1e3;
	delay_s1 = (wres_s1/(double)_p_s1->get_fanout())*((wcap_s1/(double)_p_s1->get_fanout()) + capacitance_s1);
	_p_s1->add_to_net_load(capacitance_s1);
	_p_s1->set_net_delay(delay_s1);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * mux4_2::celltype = "mux4_2";
const double mux4_2::leakage_power = 4.0972e-07;
const double mux4_2::capacitance_ip1 = 9.9824;
const double mux4_2::fanout_load_ip1 = 2;
const double mux4_2::capacitance_ip2 = 9.8707;
const double mux4_2::fanout_load_ip2 = 2;
const double mux4_2::capacitance_ip3 = 9.805;
const double mux4_2::fanout_load_ip3 = 2;
const double mux4_2::capacitance_ip4 = 10.481;
const double mux4_2::fanout_load_ip4 = 2;
const double mux4_2::capacitance_s0 = 20.357;
const double mux4_2::fanout_load_s0 = 4;
const double mux4_2::capacitance_s1 = 14.819;
const double mux4_2::fanout_load_s1 = 3;
const double mux4_2::max_capacitance_op = 250;
const double mux4_2::max_fanout_op = 50;

const double mux4_2::power_ip1_fall[4] = {
	114.16, 114.16, 114.16, 114.16
};
const double mux4_2::col_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip1_rise[4] = {
	119.65, 119.65, 119.65, 119.65
};
const double mux4_2::col_ip1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip2_fall[4] = {
	109.9, 109.9, 109.9, 109.9
};
const double mux4_2::col_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip2_rise[4] = {
	115.07, 115.07, 115.07, 115.07
};
const double mux4_2::col_ip2_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip3_fall[4] = {
	110.23, 110.23, 110.23, 110.23
};
const double mux4_2::col_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip3_rise[4] = {
	115.61, 115.61, 115.61, 115.61
};
const double mux4_2::col_ip3_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip4_fall[4] = {
	115.47, 115.47, 115.47, 115.47
};
const double mux4_2::col_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_ip4_rise[4] = {
	120.68, 120.68, 120.68, 120.68
};
const double mux4_2::col_ip4_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_s0_fall[4] = {
	90.148, 90.148, 90.148, 90.148
};
const double mux4_2::col_s0_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_s0_rise[4] = {
	91.936, 91.935, 91.935, 91.935
};
const double mux4_2::col_s0_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_s1_fall[4] = {
	69.824, 69.806, 69.8, 69.796
};
const double mux4_2::col_s1_fall[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_s1_rise[4] = {
	70.715, 70.7, 70.694, 70.689
};
const double mux4_2::col_s1_rise[4] = {0, 66.037, 144.95, 672.54};

const double mux4_2::power_op_s1[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_s1[4] = {0, 20, 50, 250};
const double mux4_2::col_op_s1[4] = {0, 62.88, 135.11, 625.42};

const double mux4_2::power_op_s0[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_s0[4] = {0, 20, 50, 250};
const double mux4_2::col_op_s0[4] = {0, 62.88, 135.11, 625.42};

const double mux4_2::power_op_ip1[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_ip1[4] = {0, 20, 50, 250};
const double mux4_2::col_op_ip1[4] = {0, 62.88, 135.11, 625.42};

const double mux4_2::power_op_ip2[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_ip2[4] = {0, 20, 50, 250};
const double mux4_2::col_op_ip2[4] = {0, 62.88, 135.11, 625.42};

const double mux4_2::power_op_ip3[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_ip3[4] = {0, 20, 50, 250};
const double mux4_2::col_op_ip3[4] = {0, 62.88, 135.11, 625.42};

const double mux4_2::power_op_ip4[4][4] = {
	{147.27, 137.78, 147.98, 154.54},
	{137.78, 218.62, 138.15, 143.78},
	{133.43, 202.78, 133.45, 138.2},
	{128.13, 192.37, 127.89, 131.72}
};
const double mux4_2::lin_op_ip4[4] = {0, 20, 50, 250};
const double mux4_2::col_op_ip4[4] = {0, 62.88, 135.11, 625.42};

// MODULE: ABnorC
// PROCESS NAME: proc
void ABnorC::proc()
{
	op.write(
		( ( ip1.read() & ip2.read() ) | ip3.read() ) 
	);
}

ABnorC::~ABnorC()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	PSC_INSERT_CELL(info);
#endif
}

void ABnorC::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * ABnorC::celltype = "ABnorC";
const double ABnorC::leakage_power = 2.48079e-08;
const double ABnorC::capacitance_ip1 = 4.4887;
const double ABnorC::fanout_load_ip1 = 1;
const double ABnorC::capacitance_ip2 = 4.6946;
const double ABnorC::fanout_load_ip2 = 1;
const double ABnorC::capacitance_ip3 = 4.6096;
const double ABnorC::fanout_load_ip3 = 1;
const double ABnorC::max_capacitance_op = 250;
const double ABnorC::max_fanout_op = 50;

const double ABnorC::power_op_ip1_fall[4][4] = {
	{80.093, 18.149, 19.994, 44.831},
	{71.567, 18.267, 19.33, 39.218},
	{63.767, 18.263, 19.049, 34.862},
	{43.53, 18.472, 18.852, 25.843}
};
const double ABnorC::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double ABnorC::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double ABnorC::power_op_ip1_rise[4][4] = {
	{60.548, 11.533, 32.531, 0.35614},
	{43.634, 17.609, 0, 0},
	{21.729, 0, 0, 0},
	{9.3493, 0, 0, 0}
};
const double ABnorC::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double ABnorC::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

// MODULE: not_ab_or_c_or_d
// PROCESS NAME: proc
void not_ab_or_c_or_d::proc()
{
	op.write(
		! ( ( ip1.read() & ip2.read() ) | ip3.read() | ip4.read() ) 
	);
}

not_ab_or_c_or_d::~not_ab_or_c_or_d()
{
#ifdef POWER_SIM

	sc_interface *_if_ip1 = ip1.get_interface();
	psc_objinfo_if *_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);

	sc_interface *_if_ip2 = ip2.get_interface();
	psc_objinfo_if *_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);

	sc_interface *_if_ip3 = ip3.get_interface();
	psc_objinfo_if *_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);

	sc_interface *_if_ip4 = ip4.get_interface();
	psc_objinfo_if *_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);

	sc_interface *_if_op = op.get_interface();
	psc_objinfo_if *_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);

	int i, j;
	bool p_set;

	psc_point_t pts_op_ip1_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_fall[j]) {
					pts_op_ip1_fall[0].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[0].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[0].z = power_op_ip1_fall[i-1][j-1];

					pts_op_ip1_fall[1].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[1].x = lin_op_ip1_fall[i-1];
					pts_op_ip1_fall[1].z = power_op_ip1_fall[i-1][j];

					pts_op_ip1_fall[2].y = col_op_ip1_fall[j];
					pts_op_ip1_fall[2].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[2].z = power_op_ip1_fall[i][j];

					pts_op_ip1_fall[3].y = col_op_ip1_fall[j-1];
					pts_op_ip1_fall[3].x = lin_op_ip1_fall[i];
					pts_op_ip1_fall[3].z = power_op_ip1_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_fall = psc_geometric_centroid(pts_op_ip1_fall, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip1_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip1_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip1->get_net_delay() < col_op_ip1_rise[j]) {
					pts_op_ip1_rise[0].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[0].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[0].z = power_op_ip1_rise[i-1][j-1];

					pts_op_ip1_rise[1].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[1].x = lin_op_ip1_rise[i-1];
					pts_op_ip1_rise[1].z = power_op_ip1_rise[i-1][j];

					pts_op_ip1_rise[2].y = col_op_ip1_rise[j];
					pts_op_ip1_rise[2].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[2].z = power_op_ip1_rise[i][j];

					pts_op_ip1_rise[3].y = col_op_ip1_rise[j-1];
					pts_op_ip1_rise[3].x = lin_op_ip1_rise[i];
					pts_op_ip1_rise[3].z = power_op_ip1_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip1_rise = psc_geometric_centroid(pts_op_ip1_rise, _p_op->get_net_load(), _p_ip1->get_net_delay());

	psc_point_t pts_op_ip2_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_fall[j]) {
					pts_op_ip2_fall[0].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[0].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[0].z = power_op_ip2_fall[i-1][j-1];

					pts_op_ip2_fall[1].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[1].x = lin_op_ip2_fall[i-1];
					pts_op_ip2_fall[1].z = power_op_ip2_fall[i-1][j];

					pts_op_ip2_fall[2].y = col_op_ip2_fall[j];
					pts_op_ip2_fall[2].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[2].z = power_op_ip2_fall[i][j];

					pts_op_ip2_fall[3].y = col_op_ip2_fall[j-1];
					pts_op_ip2_fall[3].x = lin_op_ip2_fall[i];
					pts_op_ip2_fall[3].z = power_op_ip2_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_fall = psc_geometric_centroid(pts_op_ip2_fall, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip2_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip2_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip2->get_net_delay() < col_op_ip2_rise[j]) {
					pts_op_ip2_rise[0].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[0].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[0].z = power_op_ip2_rise[i-1][j-1];

					pts_op_ip2_rise[1].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[1].x = lin_op_ip2_rise[i-1];
					pts_op_ip2_rise[1].z = power_op_ip2_rise[i-1][j];

					pts_op_ip2_rise[2].y = col_op_ip2_rise[j];
					pts_op_ip2_rise[2].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[2].z = power_op_ip2_rise[i][j];

					pts_op_ip2_rise[3].y = col_op_ip2_rise[j-1];
					pts_op_ip2_rise[3].x = lin_op_ip2_rise[i];
					pts_op_ip2_rise[3].z = power_op_ip2_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip2_rise = psc_geometric_centroid(pts_op_ip2_rise, _p_op->get_net_load(), _p_ip2->get_net_delay());

	psc_point_t pts_op_ip3_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_fall[j]) {
					pts_op_ip3_fall[0].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[0].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[0].z = power_op_ip3_fall[i-1][j-1];

					pts_op_ip3_fall[1].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[1].x = lin_op_ip3_fall[i-1];
					pts_op_ip3_fall[1].z = power_op_ip3_fall[i-1][j];

					pts_op_ip3_fall[2].y = col_op_ip3_fall[j];
					pts_op_ip3_fall[2].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[2].z = power_op_ip3_fall[i][j];

					pts_op_ip3_fall[3].y = col_op_ip3_fall[j-1];
					pts_op_ip3_fall[3].x = lin_op_ip3_fall[i];
					pts_op_ip3_fall[3].z = power_op_ip3_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_fall = psc_geometric_centroid(pts_op_ip3_fall, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip3_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip3_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip3->get_net_delay() < col_op_ip3_rise[j]) {
					pts_op_ip3_rise[0].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[0].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[0].z = power_op_ip3_rise[i-1][j-1];

					pts_op_ip3_rise[1].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[1].x = lin_op_ip3_rise[i-1];
					pts_op_ip3_rise[1].z = power_op_ip3_rise[i-1][j];

					pts_op_ip3_rise[2].y = col_op_ip3_rise[j];
					pts_op_ip3_rise[2].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[2].z = power_op_ip3_rise[i][j];

					pts_op_ip3_rise[3].y = col_op_ip3_rise[j-1];
					pts_op_ip3_rise[3].x = lin_op_ip3_rise[i];
					pts_op_ip3_rise[3].z = power_op_ip3_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip3_rise = psc_geometric_centroid(pts_op_ip3_rise, _p_op->get_net_load(), _p_ip3->get_net_delay());

	psc_point_t pts_op_ip4_fall[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_fall[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_fall[j]) {
					pts_op_ip4_fall[0].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[0].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[0].z = power_op_ip4_fall[i-1][j-1];

					pts_op_ip4_fall[1].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[1].x = lin_op_ip4_fall[i-1];
					pts_op_ip4_fall[1].z = power_op_ip4_fall[i-1][j];

					pts_op_ip4_fall[2].y = col_op_ip4_fall[j];
					pts_op_ip4_fall[2].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[2].z = power_op_ip4_fall[i][j];

					pts_op_ip4_fall[3].y = col_op_ip4_fall[j-1];
					pts_op_ip4_fall[3].x = lin_op_ip4_fall[i];
					pts_op_ip4_fall[3].z = power_op_ip4_fall[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_fall = psc_geometric_centroid(pts_op_ip4_fall, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_point_t pts_op_ip4_rise[4];
	for (p_set=false, i=1 ; i<4 ; i++) {
		if (_p_op->get_net_load() < lin_op_ip4_rise[i])
			for (j=1 ; j<4 ; j++)
				if (_p_ip4->get_net_delay() < col_op_ip4_rise[j]) {
					pts_op_ip4_rise[0].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[0].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[0].z = power_op_ip4_rise[i-1][j-1];

					pts_op_ip4_rise[1].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[1].x = lin_op_ip4_rise[i-1];
					pts_op_ip4_rise[1].z = power_op_ip4_rise[i-1][j];

					pts_op_ip4_rise[2].y = col_op_ip4_rise[j];
					pts_op_ip4_rise[2].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[2].z = power_op_ip4_rise[i][j];

					pts_op_ip4_rise[3].y = col_op_ip4_rise[j-1];
					pts_op_ip4_rise[3].x = lin_op_ip4_rise[i];
					pts_op_ip4_rise[3].z = power_op_ip4_rise[i][j-1];
					p_set = true;
					break;
				}
		if (p_set)
			break;
	}

	if (!p_set)
		cerr << "ERROR: psc_point_t vector not set" << endl;

	double E_op_ip4_rise = psc_geometric_centroid(pts_op_ip4_rise, _p_op->get_net_load(), _p_ip4->get_net_delay());

	psc_cell_power_info info(name(), celltype);

	info.set_level(PSC_GATE_LEVEL);
	info.set_leak_power(leakage_power);
	psc_pin_power_info pwr_op_ip1_fall(_p_op->get_id(), E_op_ip1_fall);
	pwr_op_ip1_fall.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_fall);
	psc_pin_power_info pwr_op_ip1_rise(_p_op->get_id(), E_op_ip1_rise);
	pwr_op_ip1_rise.set_rel_pins(1, _p_ip1->get_id().c_str());
	info.add(pwr_op_ip1_rise);
	psc_pin_power_info pwr_op_ip2_fall(_p_op->get_id(), E_op_ip2_fall);
	pwr_op_ip2_fall.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_fall);
	psc_pin_power_info pwr_op_ip2_rise(_p_op->get_id(), E_op_ip2_rise);
	pwr_op_ip2_rise.set_rel_pins(1, _p_ip2->get_id().c_str());
	info.add(pwr_op_ip2_rise);
	psc_pin_power_info pwr_op_ip3_fall(_p_op->get_id(), E_op_ip3_fall);
	pwr_op_ip3_fall.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_fall);
	psc_pin_power_info pwr_op_ip3_rise(_p_op->get_id(), E_op_ip3_rise);
	pwr_op_ip3_rise.set_rel_pins(1, _p_ip3->get_id().c_str());
	info.add(pwr_op_ip3_rise);
	psc_pin_power_info pwr_op_ip4_fall(_p_op->get_id(), E_op_ip4_fall);
	pwr_op_ip4_fall.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_fall);
	psc_pin_power_info pwr_op_ip4_rise(_p_op->get_id(), E_op_ip4_rise);
	pwr_op_ip4_rise.set_rel_pins(1, _p_ip4->get_id().c_str());
	info.add(pwr_op_ip4_rise);
	PSC_INSERT_CELL(info);
#endif
}

void not_ab_or_c_or_d::end_of_elaboration()
{
#ifdef POWER_SIM
	double wcap_ip1, delay_ip1, wres_ip1, wcap_ip2, delay_ip2, wres_ip2, wcap_ip3, delay_ip3, wres_ip3, wcap_ip4, delay_ip4, wres_ip4, wcap_op;
	sc_interface *_if_ip1, *_if_ip2, *_if_ip3, *_if_ip4, *_if_op;
	psc_objinfo_if *_p_ip1, *_p_ip2, *_p_ip3, *_p_ip4, *_p_op;

	_if_ip1 = ip1.get_interface();
	_p_ip1 = dynamic_cast<psc_objinfo_if*>(_if_ip1);
	wcap_ip1 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1];
	_p_ip1->set_wire_load(wcap_ip1);
	wres_ip1 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip1->get_fanout()-1] * 1e3;
	delay_ip1 = (wres_ip1/(double)_p_ip1->get_fanout())*((wcap_ip1/(double)_p_ip1->get_fanout()) + capacitance_ip1);
	_p_ip1->add_to_net_load(capacitance_ip1);
	_p_ip1->set_net_delay(delay_ip1);

	_if_ip2 = ip2.get_interface();
	_p_ip2 = dynamic_cast<psc_objinfo_if*>(_if_ip2);
	wcap_ip2 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1];
	_p_ip2->set_wire_load(wcap_ip2);
	wres_ip2 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip2->get_fanout()-1] * 1e3;
	delay_ip2 = (wres_ip2/(double)_p_ip2->get_fanout())*((wcap_ip2/(double)_p_ip2->get_fanout()) + capacitance_ip2);
	_p_ip2->add_to_net_load(capacitance_ip2);
	_p_ip2->set_net_delay(delay_ip2);

	_if_ip3 = ip3.get_interface();
	_p_ip3 = dynamic_cast<psc_objinfo_if*>(_if_ip3);
	wcap_ip3 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1];
	_p_ip3->set_wire_load(wcap_ip3);
	wres_ip3 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip3->get_fanout()-1] * 1e3;
	delay_ip3 = (wres_ip3/(double)_p_ip3->get_fanout())*((wcap_ip3/(double)_p_ip3->get_fanout()) + capacitance_ip3);
	_p_ip3->add_to_net_load(capacitance_ip3);
	_p_ip3->set_net_delay(delay_ip3);

	_if_ip4 = ip4.get_interface();
	_p_ip4 = dynamic_cast<psc_objinfo_if*>(_if_ip4);
	wcap_ip4 = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1];
	_p_ip4->set_wire_load(wcap_ip4);
	wres_ip4 = LibWireLoad::resistance * LibWireLoad::fanout_length[_p_ip4->get_fanout()-1] * 1e3;
	delay_ip4 = (wres_ip4/(double)_p_ip4->get_fanout())*((wcap_ip4/(double)_p_ip4->get_fanout()) + capacitance_ip4);
	_p_ip4->add_to_net_load(capacitance_ip4);
	_p_ip4->set_net_delay(delay_ip4);

	_if_op = op.get_interface();
	_p_op = dynamic_cast<psc_objinfo_if*>(_if_op);
	wcap_op = LibWireLoad::capacitance * LibWireLoad::fanout_length[_p_op->get_fanout()-1];
	_p_op->set_wire_load(wcap_op);
#endif
}
const char * not_ab_or_c_or_d::celltype = "not_ab_or_c_or_d";
const double not_ab_or_c_or_d::leakage_power = 2.03975e-08;
const double not_ab_or_c_or_d::capacitance_ip1 = 4.8422;
const double not_ab_or_c_or_d::fanout_load_ip1 = 1;
const double not_ab_or_c_or_d::capacitance_ip2 = 5.0853;
const double not_ab_or_c_or_d::fanout_load_ip2 = 1;
const double not_ab_or_c_or_d::capacitance_ip3 = 4.8863;
const double not_ab_or_c_or_d::fanout_load_ip3 = 1;
const double not_ab_or_c_or_d::capacitance_ip4 = 4.8213;
const double not_ab_or_c_or_d::fanout_load_ip4 = 1;
const double not_ab_or_c_or_d::max_capacitance_op = 250;
const double not_ab_or_c_or_d::max_fanout_op = 50;

const double not_ab_or_c_or_d::power_op_ip1_fall[4][4] = {
	{81.445, 77.504, 80.656, 147.91},
	{81.657, 77.641, 79.097, 131.43},
	{81.596, 77.696, 78.441, 118.88},
	{81.271, 77.463, 77.361, 95.352}
};
const double not_ab_or_c_or_d::lin_op_ip1_fall[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip1_fall[4] = {0, 66.037, 144.95, 672.54};

const double not_ab_or_c_or_d::power_op_ip1_rise[4][4] = {
	{62.809, 59.353, 58.768, 105.73},
	{62.73, 59.86, 59.069, 93.691},
	{62.678, 60.448, 59.375, 84.925},
	{62.597, 60.684, 59.784, 69.596}
};
const double not_ab_or_c_or_d::lin_op_ip1_rise[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip1_rise[4] = {0, 59.722, 125.27, 578.29};

const double not_ab_or_c_or_d::power_op_ip2_fall[4][4] = {
	{76.636, 73.503, 76.838, 140.88},
	{76.816, 73.791, 75.473, 124.71},
	{76.771, 73.99, 74.714, 112.35},
	{76.469, 73.693, 73.706, 89.962}
};
const double not_ab_or_c_or_d::lin_op_ip2_fall[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip2_fall[4] = {0, 66.037, 144.95, 672.54};

const double not_ab_or_c_or_d::power_op_ip2_rise[4][4] = {
	{54.756, 49.942, 49.287, 93.154},
	{55.055, 51.989, 50.366, 81.78},
	{55.062, 52.998, 51.345, 74.208},
	{55.019, 53.858, 52.734, 61.341}
};
const double not_ab_or_c_or_d::lin_op_ip2_rise[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip2_rise[4] = {0, 59.722, 125.27, 578.29};

const double not_ab_or_c_or_d::power_op_ip3_fall[4][4] = {
	{51.266, 49.523, 55.229, 127.72},
	{51.436, 49.522, 53.152, 111.85},
	{51.55, 49.955, 52.282, 99.191},
	{51.032, 49.143, 50.649, 73.532}
};
const double not_ab_or_c_or_d::lin_op_ip3_fall[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip3_fall[4] = {0, 66.037, 144.95, 672.54};

const double not_ab_or_c_or_d::power_op_ip3_rise[4][4] = {
	{41.552, 37.244, 40.414, 99.47},
	{41.734, 38.371, 39.418, 86.426},
	{41.721, 39.137, 39.324, 76.337},
	{41.678, 39.986, 39.733, 55.552}
};
const double not_ab_or_c_or_d::lin_op_ip3_rise[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip3_rise[4] = {0, 59.722, 125.27, 578.29};

const double not_ab_or_c_or_d::power_op_ip4_fall[4][4] = {
	{34.96, 34.918, 40.607, 103.9},
	{35.276, 35.901, 39.411, 90.078},
	{35.363, 36.589, 38.828, 79.459},
	{34.812, 36.995, 37.873, 58.765}
};
const double not_ab_or_c_or_d::lin_op_ip4_fall[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip4_fall[4] = {0, 66.037, 144.95, 672.54};

const double not_ab_or_c_or_d::power_op_ip4_rise[4][4] = {
	{32.838, 31.487, 37.251, 89.526},
	{33.103, 31.855, 35.138, 78.372},
	{33.071, 32.254, 34.095, 69.419},
	{33, 33.048, 33.46, 49.17}
};
const double not_ab_or_c_or_d::lin_op_ip4_rise[4] = {0, 20, 50, 250};
const double not_ab_or_c_or_d::col_op_ip4_rise[4] = {0, 59.722, 125.27, 578.29};
